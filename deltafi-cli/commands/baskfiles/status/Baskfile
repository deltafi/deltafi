BASE_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
source $DELTAFICLI_WORKDIR/concurrent.lib.sh
source $DELTAFICLI_WORKDIR/common

DEPLOYMENTS=( \
  deltafi-gateway \
  deltafi-core-actions \
  deltafi-core-domain \
  deltafi-ingress \
  deltafi-kibana \
  deltafi-kubernetes-dashboard \
  deltafi-minio \
  deltafi-mongodb \
  deltafi-nifi \
  deltafi-passthrough-actions \
  deltafi-zipkin \
)

VOLUMES=( \
  deltafi-elasticsearch \
  deltafi-minio \
  deltafi-mongodb \
  deltafi-nifi \
)

SERVICES=( \
  deltafi-gateway-service \
  deltafi-core-domain-service \
  deltafi-fluentd \
  deltafi-ingress-service \
  deltafi-kibana \
  deltafi-kubernetes-dashboard \
  deltafi-minio \
  deltafi-mongodb \
  deltafi-redis-master \
  deltafi-zipkin \
  elasticsearch-master \
  nifi-egress-service \
  nifi-ui-service \
)

INGRESSES=( \
  deltafi-gateway-ingress \
  deltafi-ingress \
  deltafi-kibana \
  deltafi-kubernetes-dashboard \
  deltafi-minio \
  deltafi-zipkin \
  nifi-ui-ingress \
)

CHECKS=( helm deployments pods services ingresses storage )

_check_description() {
  case $1 in
    'helm')        echo 'Checking helm status';;
    'deployments') echo 'Checking Kubernetes Deployments';;
    'pods')        echo 'Checking Kubernetes Pods';;
    'services')    echo 'Checking Kubernetes Services';;
    'ingresses')   echo 'Checking Kubernetes Ingress';;
    'storage')     echo 'Checking Kubernetes Storage';;
  esac
}

_kubectl() {
  kubectl --namespace $DELTAFICLI_K8S_NAMESPACE $@
}

_join_arr() {
  local IFS="$1"
  shift
  echo "$*"
}

_give_recommendation() {
  echo -en "${bold}\n"
  echo -e "Recommendation: $1"
  shift
  while [[ $# -gt 0 ]]; do
    echo -e "                $1"
    shift
  done
  echo -e "${normal}"
}

helm_status() {
  local status=0

  local helm_output=$(helm status $DELTAFICLI_PROJECT_NAME -n $DELTAFICLI_K8S_NAMESPACE)
  if [[ ! "$helm_output" =~ "STATUS: deployed" ]]; then
    _warn echo -e "Helm status check failed:\n$helm_output"
    _give_recommendation "Run the installer" "$ deltafi install"
    status=1
  fi

  return $status
}

deployments_status() {
  local status=0

  for deployment in "${DEPLOYMENTS[@]}"; do
    echo "deployment/$deployment" >&3
    local k_output="$(_kubectl get deployment $deployment | grep -v NAME)"

    if [[ "$k_output" == "" ]]; then
      _warn echo -e "$deployment deployment missing"
      _give_recommendation "Run the installer" "$ deltafi install"
      status=1
      continue
    fi

    echo >&3
  done

  return $status
}

pods_status() {
  local status=0

  local pods="$(_kubectl get pods -o custom-columns=NAME:metadata.name,STARTED:status.containerStatuses[*].started,READY:status.containerStatuses[*].ready)"
  if [[ "$pods" =~ "false" ]]; then
    local bad_pods="$(echo "$pods" | grep false | awk '{print $1}' | xargs | tr ' ' '|')"
    echo "$bad_pods"
    local kubectl_output=$(_kubectl get pods | egrep "$bad_pods|^NAME")
    _warn echo -e "Pods are unhealthy:\n$kubectl_output"
    _give_recommendation "Check the logs" "$ kubectl logs <pod name>"
    status=1
  fi

  return $status
}

services_status() {
  set +e
  local status=0

  for service in "${SERVICES[@]}"; do
    echo "svc/$service" >&3
    local svc=$(_kubectl get svc $service | grep -v None | grep -v NAME)
    local selector=$(_kubectl get svc $service -o jsonpath='{.spec.selector}' | tr -d '\{\}"' | tr ':' '=')

    if [[ "$svc" == "" ]]; then
      _warn echo -e "$service service missing"
      _give_recommendation "Run the installer" "$ deltafi install"
      status=1
      continue
    fi

    unset IFS
    read -r NAME _ IP _ PORTS _ <<< "$svc"
    IFS=',' read -r -a PORTS_ARRAY <<< ${PORTS}
    for PORT in "${PORTS_ARRAY[@]}"; do
      IFS='/' read -r PORT_NUMS PROTO <<< ${PORT}
      IFS=':' read -r PORT_NUM _ <<< ${PORT_NUMS}
      URL="${PROTO,,}://${IP}:${PORT_NUM}"
      nc -z ${IP} ${PORT_NUM}
      if [[ ! $? -eq 0 ]]; then
        _warn echo "Could not connect to ${URL} (${NAME})"
        _give_recommendation "Check the logs of the underlying pod" "$ kubectl logs -l ${selector}"
        status=1
      fi
    done
    echo >&3
  done

  return $status
}

_storage_status() {
  local type=$1
  local status=0

  for volume in "${VOLUMES[@]}"; do
    echo "$type/$volume" >&3
    local output="$(_kubectl get $type $volume 2>&1)"
    if [[ ! "$output" =~ "Bound" ]]; then
      _warn echo -e "Issue with $type $volume: \n$output"
      _give_recommendation "Run ansible"
      status=1
    fi
    echo >&3
  done

  return $status
}

storage_status() {
  _storage_status pv
  _storage_status pvc
}

ingresses_status() {
  local status=0

  for ingress in "${INGRESSES[@]}"; do
    echo "ingress/$ingress" >&3
    local k_output="$(_kubectl get ingress $ingress | grep -v NAME)"
    local columns="$(echo "$k_output" | awk '{print NF}')"

    if [[ "$k_output" == "" ]]; then
      _warn echo -e "$ingress ingress missing"
      _give_recommendation "Run the installer" "$ deltafi install"
      status=1
      continue
    fi

    if [[ "$columns" -lt "6" ]]; then
      _warn echo -e "ingress/$ingress not fully initialized."
      _give_recommendation "Wait for ingress to initialize. Could take up to 60 seconds."
      status=1
      continue
    fi

    unset IFS
    read -r _ _ host addrs ports _ <<< "$k_output"
    IFS=',' read -r host <<< ${addrs}
    local ip="$(getent ahosts $addr | head -1 | awk '{print $1}')"
    IFS=', ' read -r port _ <<< ${ports}
    local schema="http"
    [[ "$port" -eq "443" ]] && schema+="s"

    set +e
    local curl_output=$(curl -k -sS -o /dev/null --resolve "$host:$port:$ip" "$schema://$host" 2>&1)
    if [[ "$curl_output" != "" ]]; then
      _warn echo -e "Issue with ingress $ingress: \n$curl_output"
      _give_recommendation "Run the installer" "$ deltafi install"
      status=1
    fi

    echo >&3
  done

  return $status
}

describe "status" <<HEREDOC
Usage:
  status [options]

Options:
  -s, --skip $(_join_arr , "${CHECKS[@]}")

Description:
  Check system status.
HEREDOC
status() {
  local parallel_jobs=()

  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
      -s|--skip)
        SKIP="$2"
        [[ -z $SKIP ]] && _exit_1 echo "$1 requires an argument"
        shift # past argument
        shift # past value
        ;;
      "")
        shift
        ;;
      *)
        _exit_1 echo "Unknown options: $1"
        ;;
    esac
  done

  for check in "${CHECKS[@]}"; do
    [[ "$SKIP" =~ "$check" ]] || parallel_jobs+=( - "$(_check_description $check)" "${check}_status" )
  done

  concurrent "${parallel_jobs[@]}"
}
