# vim: filetype=bash

___start=$(date +%s)

_emit_duration() {
  local duration=$(echo "$(date +%s) - $___start" | bc)
  local execution_time=`printf "%d seconds" $duration`
  echo "Execution time: $execution_time"
}

trap _emit_duration EXIT

BASE_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
CONFIG_REPO=git@gitlab.com:systolic/deltafi/deltafi-config
PV_DIR=$BASE_PATH/data/pv

SUDO=$(which sudo)

CLUSTER_NAME=deltafi

FQDNS=( \
  local.deltafi.org \
  minio.local.deltafi.org \
  k8s.local.deltafi.org \
  egress.local.deltafi.org \
)

_initialize_config() {
  if [[ ! -d $BASE_PATH/config/.git ]]; then
    rm -rf $BASE_PATH/config
    git clone $CONFIG_REPO $BASE_PATH/config
  fi
}

_check_deltafi_cli() {
  if ! which deltafi >/dev/null; then
    echo ">> Installing DeltaFi CLI"
    pushd $BASE_PATH/../deltafi-cli > /dev/null
    ./install.sh
    popd > /dev/null
  fi
}

_install_node_cli() {
  echo ">> Installing DeltaFi CLI in cluster node"
  docker exec -i ${CLUSTER_NAME}-control-plane bash <<"EOF"
cd /usr/dev/deltafi/deltafi-cli
./install.sh
EOF
}

_create_proxy() {
  local PROXY_NAME=$1
  local PROXY_REMOTE=$2
  local PROXY_PORT=$3
  # Create volume if not present
  if ! docker volume inspect $PROXY_NAME > /dev/null; then
    docker volume create $PROXY_NAME
  fi
  running="$(docker inspect -f '{{.State.Running}}' "${PROXY_NAME}" 2>/dev/null || true)"
  if [ "${running}" != 'true' ]; then
      docker run \
            -d --name "${PROXY_NAME}" \
            --restart=always --net=kind \
            --mount source=${PROXY_NAME},destination=/var/lib/registry \
            -e REGISTRY_PROXY_REMOTEURL=${PROXY_REMOTE} \
            -p "127.0.0.1:${PROXY_PORT}:5000" \
            registry:2
  fi
}

_create_registry() {
  local REGISTRY_NAME=$1
  local REGISTRY_PORT=$2
  # Create volume if not present
  if ! docker volume inspect $REGISTRY_NAME > /dev/null; then
    docker volume create $REGISTRY_NAME
  fi
  running="$(docker inspect -f '{{.State.Running}}' "${REGISTRY_NAME}" 2>/dev/null || true)"
  if [ "${running}" != 'true' ]; then
      docker run \
            -d --name "${REGISTRY_NAME}" \
            --restart=always --net=kind \
            --mount source=${REGISTRY_NAME},destination=/var/lib/registry \
            -p "127.0.0.1:${REGISTRY_PORT}:5000" \
            registry:2
  fi
}

_cluster_up() {
  echo ">> Initializing KinD cluster..."
  _check_deltafi_cli
  mkdir -p $PV_DIR
  pushd $BASE_PATH > /dev/null
  if kind get clusters | grep "^${CLUSTER_NAME}$" > /dev/null; then
    echo "${CLUSTER_NAME} cluster already instantiated"
  else
    cat <<EOF | kind create cluster --wait 10m --name ${CLUSTER_NAME} --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  image: deltafi/deltafi-kind-node:beta
  kubeadmConfigPatches:
  - |
    kind: InitConfiguration
    nodeRegistration:
      kubeletExtraArgs:
        node-labels: "ingress-ready=true,node-role.deltafi.org/compute=true,node-role.deltafi.org/storage=true"
  extraPortMappings:
  - containerPort: 80
    hostPort: 80
    protocol: TCP
  - containerPort: 443
    hostPort: 443
    protocol: TCP
  extraMounts:
  - hostPath: "../.."
    containerPath: /usr/dev
  - hostPath: "${PV_DIR}"
    containerPath: /data/deltafi/pv
  - hostPath: ./config
    containerPath: /data/config-server/config
containerdConfigPatches:
- |-
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
    endpoint = ["http://dockerio-proxy:5000"]
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."k8s.gcr.io"]
    endpoint = ["http://k8s-proxy:5000"]
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:5000"]
    endpoint = ["http://kind-registry:5000"]
EOF
  fi
  _create_registry kind-registry 5000
  _create_proxy dockerio-proxy "https://registry-1.docker.io" 5001
  _create_proxy k8s-proxy "https://k8s.gcr.io" 5002

  _k8s_add_namespace deltafi

  kubectl apply -f $BASE_PATH/k8s/kind-metrics-server-deployment.yaml
  kubens deltafi
  _install_node_cli
  _enable_ui
  echo "<< Initializing KinD cluster...complete"
}

_k8s_add_namespace() {
  local ns=$1
  if ! kubectl get namespace $ns 2>&1 > /dev/null; then
    echo "  Creating namespace: $ns"
    cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: $ns
EOF
  fi
}

_k8s_add_pv() {
  local name=$1
  local path=${2:-${PV_DIR}/${name}}
  local size=${3:-1G}
  local namespace=${4:-deltafi}
  if ! kubectl get persistentvolumeclaim $name 2>&1 > /dev/null; then
    echo "  Installing persistent volume: $name ($path)"
    cat <<EOF | kubectl apply -f -
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: $name
  namespace: $namespace
spec:
  storageClassName: manual
  selector:
    matchLabels:
      app: $name
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: $size
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: $name
  labels:
    app: $name
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: $size
  claimRef:
    apiVersion: v1
    kind: PersistentVolumeClaim
    name: $name
    namespace: $namespace
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: "$path"
---
EOF
  fi
}

_k8s_add_secret() {
  local name=$1
  shift

  if ! kubectl get secret $name 2>&1 > /dev/null; then
    echo "  Installing secret: $name"
    cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: $name
  namespace: deltafi
data:
$(while (( "$#" )); do
local pass=$(printf $2 | base64)
echo "  $1: $pass"
shift 2
done)
EOF
  fi
}

_random_password() {
  local size=${1:-20}
  printf $(printf $RANDOM | md5sum | head -c 20)$(printf $RANDOM | md5sum | head -c 20)$(printf $RANDOM | md5sum | head -c 20) | base64 | head -c $size
}

_enable_ui() {
  echo ">> Installing KinD ingress controller..."
  _check_local_fqdns
  echo " >  Installing ingress-nginx..."
  kubectl apply -f $BASE_PATH/k8s/ingress-nginx.yaml | while read line; do echo " |  $line"; done
  # echo " >  Waiting for ingress-nginx..."
  # kubectl wait --namespace ingress-nginx \
  #     --for=condition=ready pod \
  #     --selector=app.kubernetes.io/component=controller \
  #     --timeout=90s | while read line; do echo " |  $line"; done
  echo "<< Installing KinD ingress controller...complete"
}

_verify_or_replace_fqdn() {
  local FQDN=$1
  if grep -qxF "127.0.0.1 $FQDN" /etc/hosts; then
    echo "   OK     $FQDN"
  else
    echo "127.0.0.1 $FQDN" | ${SUDO} tee -a /etc/hosts > /dev/null
    echo "   ADDED  $FQDN"
  fi
}

_check_local_fqdns() {
  echo ">> Checking /etc/hosts config"
  echo "   You may be prompted for your sudo password"

  for fqdn in "${FQDNS[@]}"; do
    _verify_or_replace_fqdn $fqdn
  done
}


describe install "Initialize a KinD cluster and install core DeltaFi"
install() {
  _initialize_config
  _deltafi_install "$@"
}

_deltafi_install() {
  echo ">> Installing deltafi"
  _k8s_add_namespace deltafi
  _k8s_add_secret mongodb-passwords mongodb-password $(_random_password 20) mongodb-root-password $(_random_password 20)
  _k8s_add_secret minio-keys accesskey $(_random_password 20) secretkey $(_random_password 40)
  _k8s_add_secret redis-password redis-password $(_random_password 16)
  _k8s_add_secret config-repo-secret config-token $(_random_password 16)
  _k8s_add_pv deltafi-mongodb /data/deltafi/pv/mongodb 1G
  _k8s_add_pv deltafi-elasticsearch /data/deltafi/pv/elasticsearch 1G
  _k8s_add_pv deltafi-minio /data/deltafi/pv/minio 1G
  _k8s_add_pv deltafi-egress-sink /data/deltafi/pv/egress-sink 1G
  _k8s_add_pv deltafi-auth /data/deltafi/pv/auth 1G
  kind_deltafi install -f deltafi/kind/values-kind.yaml "$@" 2>&1 | grep -v deprecated | while read line; do echo " |  $line"; done
  echo "<< Installing deltafi complete"
}


_cluster_down() {
  if kind get clusters 2>/dev/null | grep "^${CLUSTER_NAME}$" > /dev/null; then
    kind delete cluster --name ${CLUSTER_NAME}
    rm -rf $PV_DIR/mongodb
  else
    echo "No deltafi cluster instantiated"
  fi
}

_manifest() {
  docker exec -it ${CLUSTER_NAME}-control-plane crictl images | sed '1d' | tr -s ' ' | sed 's| |:|' | sed 's| .*||'
}

_cluster_clean() {
  _cluster_down
  rm -rf $PV_DIR
}

cluster() {

  case "$1" in
    up)
      _cluster_up
      ;;
    down)
      _cluster_down
      ;;
    clean)
      _cluster_clean
      ;;
    shell)
      _shell
      ;;
    manifest)
      _manifest
      ;;
    -h|*)
      cat <<EOF
Command: cluster

Usage:
  cluster [up | down | clean | manifest | shell | ui ]

Options:
  up        Turn up a KinD cluster (or re-apply cluster settings)
  down      Shut down a cluster
  clean     Shut down a cluster and clean out all mounts (except for docker images)
  manifest  List all docker images in use in the cluster
  shell     Shell to the cluster control plane node

EOF
      ;;
  esac
}

_shell() {
  echo "Launching k8s cluster shell..."
  docker exec -w /usr/dev -it ${CLUSTER_NAME}-control-plane tmux -2 new-session -A -s KinD
}

kind_deltafi() {
  docker exec -i ${CLUSTER_NAME}-control-plane bash <<EOF
cd /usr/dev
TERM=screen-256color deltafi $@
EOF
}

install_core_flow() {
  docker exec -i ${CLUSTER_NAME}-control-plane bash <<"EOF"
cd /usr/dev/deltafi/flows
for f in $(ls); do
  TERM=screen-256color deltafi load-config $f
done
EOF
}

passthrough_some_data() {
  install_core_flow
  docker exec -i ${CLUSTER_NAME}-control-plane bash <<"EOF"
cd /usr/dev/deltafi/flows
for f in $(ls); do
  TERM=screen-256color deltafi ingress passthrough $f --trace
done
EOF
}
