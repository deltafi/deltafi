scalar DateTime
scalar JSON
scalar Long

type KeyValue {
  key: String!
  value: String
}

input KeyValueInput {
  key: String!
  value: String
}

type Domain {
  name: String!
  value: String
  mediaType: String!
}

input DomainInput {
  name: String!
  value: String
  mediaType: String!
}

type Enrichment {
  name: String!
  value: String
  mediaType: String!
}

input EnrichmentInput {
  name: String!
  value: String
  mediaType: String!
}

type SourceInfo {
  filename: String!
  flow: String!
  metadata: [KeyValue!]
}

input SourceInfoInput {
  filename: String!
  flow: String!
  metadata: [KeyValueInput!]
}

input SourceInfoFilter {
  filename: String
  flow: String
  metadata: [KeyValueInput!]
}

type Content {
  name: String
  metadata: [KeyValue!]
  contentReference: ContentReference!
}

input ContentInput {
  name: String
  metadata: [KeyValueInput!]
  contentReference: ContentReferenceInput!
}

"""
A ContentReference is a reference to stored content for a delta file.
"""
type ContentReference {
  uuid: String!
  offset: Long!
  size: Long!
  did: String!
  mediaType: String!
}

input ContentReferenceInput {
  uuid: String!
  offset: Long!
  size: Long!
  did: String!
  mediaType: String!
}

"""
Ingress and transform actions create contentReferences and express additional metadata through ProtocolLayers
Followon actions get the latest "state" of the transformed object from the top of the ProtocolLayer stack
"""
type ProtocolLayer {
  "The type of ProtocolLayer"
  type: String!
  "The action that produced this ProtocolLayer"
  action: String!
  "Content produced by the action"
  content: [Content!]!
  "Additional metadata"
  metadata: [KeyValue!]
}

input ProtocolLayerInput {
  type: String!
  action: String!
  content: [ContentInput!]!
  metadata: [KeyValueInput!]
}

type FormattedData {
  filename: String!
  formatAction: String!
  contentReference: ContentReference!
  metadata: [KeyValue!]
  egressActions: [String!]!
  validateActions: [String!]!
}

input FormattedDataFilter {
  filename: String
  formatAction: String
  metadata: [KeyValueInput!]
  egressActions: [String!]
}

enum DeltaFileStage {
  INGRESS
  EGRESS
  COMPLETE
  ERROR
  DELETE
}

enum ActionState {
  QUEUED
  COMPLETE
  ERROR
  RETRIED
  FILTERED
  SPLIT
}

type Action {
  name: String!
  state: ActionState!
  created: DateTime!
  modified: DateTime!
  errorCause: String
  errorContext: String
}

enum ActionEventType {
  TRANSFORM
  LOAD
  ENRICH
  FORMAT
  VALIDATE
  EGRESS
  ERROR
  FILTER
  DELETE
  SPLIT
}

input ActionEventInput {
  did: String!
  action: String!
  time: DateTime!
  type: ActionEventType!
  transform: TransformInput
  load: LoadInput
  enrich: EnrichInput
  format: FormatInput
  error: ErrorInput
  filter: FilterInput
  split: [SplitInput]
}

type DeltaFile {
  did: String!
  parentDids: [String!]
  childDids: [String!]
  stage: DeltaFileStage!
  actions: [Action!]!
  sourceInfo: SourceInfo!
  protocolStack: [ProtocolLayer]!
  domains: [Domain!]!
  enrichment: [Enrichment!]!
  formattedData: [FormattedData]!
  created: DateTime!
  modified: DateTime!
  markedForDelete: DateTime
  markedForDeleteReason: String
  errorAcknowledged: DateTime
  errorAcknowledgedReason: String
}

input IngressInput {
  did: String!
  sourceInfo: SourceInfoInput!
  content: [ContentInput!]!
  created: DateTime!
}

input TransformInput {
  protocolLayer: ProtocolLayerInput!
}

input LoadInput {
  domains: [DomainInput!]!
  protocolLayer: ProtocolLayerInput!
}

input EnrichInput {
  enrichments: [EnrichmentInput!]!
}

input FormatInput {
  filename: String!
  contentReference: ContentReferenceInput!
  metadata: [KeyValueInput!]
}

input FilterInput {
  message: String!
}

input SplitInput {
  sourceInfo: SourceInfoInput!
  content: [ContentInput!]!
}

type DeltaFiles {
  offset: Int
  count: Int
  totalCount: Int
  deltaFiles: [DeltaFile!]!
}

input DeltaFileOrder {
  direction: DeltaFileDirection!
  # The field name is passed directly to the DB for sort
  # this is not ideal, but better than requiring hard-coding every possibility
  field: String!
}

enum DeltaFileDirection {
  ASC
  DESC
}

input DeltaFilesFilter {
  dids: [String!]
  createdAfter: DateTime
  createdBefore: DateTime
  domains: [String!]
  enrichment: [String!]
  isMarkedForDelete: Boolean
  modifiedAfter: DateTime
  modifiedBefore: DateTime
  sourceInfo: SourceInfoFilter
  stage: DeltaFileStage
  actions: [String!]
  formattedData: FormattedDataFilter
  errorAcknowledged: Boolean
}

type RetryResult {
  did: String!
  success: Boolean!
  error: String
}

type AcknowledgeResult {
  did: String!
  success: Boolean!
  error: String
}

type Query {
  flowPlans: [FlowPlan]!
  exportFlowPlan(name: String!): String!

  deltaFiles(offset: Int, limit: Int, filter: DeltaFilesFilter, orderBy: DeltaFileOrder): DeltaFiles!
  deltaFile(did: String!): DeltaFile
  lastCreated(last: Int) : [DeltaFile]!
  lastModified(last: Int) : [DeltaFile]!
  lastErrored(last: Int) : [DeltaFile]!
  lastWithFilename(filename: String!) : DeltaFile

  deltaFiConfigs(configQuery: ConfigQueryInput) : [DeltaFiConfiguration]!
  actionSchemas: [ActionSchema!]!
  exportConfigAsYaml: String!

  plugins:  [Plugin!]!
}

type Mutation {
  saveFlowPlan(flowPlan: FlowPlanInput!) : FlowPlan!
  removeFlowPlan(name: String!) : Boolean!

  ingress(input: IngressInput!): DeltaFile!
  actionEvent(event: ActionEventInput!): DeltaFile!

  retry(dids: [String!]!) : [RetryResult!]!
  acknowledge(dids: [String!]!, reason: String) : [AcknowledgeResult!]!

  registerDeleteSchema(actionSchema: DeleteActionSchemaInput!): ActionSchema!
  registerEgressSchema(actionSchema: EgressActionSchemaInput!): ActionSchema!
  registerEnrichSchema(actionSchema: EnrichActionSchemaInput!): ActionSchema!
  registerFormatSchema(actionSchema: FormatActionSchemaInput!): ActionSchema!
  registerLoadSchema(actionSchema: LoadActionSchemaInput!): ActionSchema!
  registerTransformSchema(actionSchema: TransformActionSchemaInput!): ActionSchema!
  registerValidateSchema(actionSchema: ValidateActionSchemaInput!): ActionSchema!

  replaceConfig(configYaml: String!): String
  mergeConfig(configYaml: String!): String

  removeDeltaFiConfigs(configQuery: ConfigQueryInput): Int!

  registerPlugin(pluginInput: PluginInput!): Plugin!
}
