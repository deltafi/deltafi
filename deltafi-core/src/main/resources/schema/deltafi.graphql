#
#    DeltaFi - Data transformation and enrichment platform
#
#    Copyright 2021-2023 DeltaFi Contributors <deltafi@deltafi.org>
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#

scalar DateTime
scalar Duration
scalar JSON
scalar Long
scalar Metadata

type KeyValue {
  key: String!
  value: String
}

input KeyValueInput {
  key: String!
  value: String
}

type PerActionUniqueKeyValues {
  flow: String!
  action: String!
  keyVals: [UniqueKeyValues!]!
}

type UniqueKeyValues {
  key: String!
  values: [String]!
}

type Egress {
  flow: String!
}

input NameFilter {
  name: String!
  regex: Boolean
  caseSensitive: Boolean
}

type Content {
  name: String
  segments: [Segment!]!
  mediaType: String!
  size: Long!
}

type Segment {
  uuid: String!
  offset: Long!
  size: Long!
  did: String!
}

enum DeltaFileStage {
  IN_FLIGHT
  COMPLETE
  ERROR
  CANCELLED
}

enum ActionState {
  COLD_QUEUED
  QUEUED
  COMPLETE
  ERROR
  RETRIED
  FILTERED
  SPLIT
  CANCELLED
  COLLECTING
  COLLECTED
}

enum ActionType {
  INGRESS
  TRANSFORM
  EGRESS
  PUBLISH
  UNKNOWN
}

type Action {
  name: String!
  id: Int!
  type: ActionType!
  state: ActionState!
  created: DateTime!
  queued: DateTime
  start: DateTime
  stop: DateTime
  modified: DateTime!
  errorCause: String
  errorContext: String
  errorAcknowledged: DateTime
  errorAcknowledgedReason: String
  nextAutoResume: DateTime
  nextAutoResumeReason: String
  filteredCause: String
  filteredContext: String
  attempt: Int!
  content: [Content!]!
  metadata: Metadata
  deleteMetadataKeys: [String!]!
}

type FlowPlanCoordinates {
  name: String
  plugin: String
  pluginVersion: String
}

type DeltaFileFlowInput {
  metadata: Metadata!
  content: [Content!]!
  topics: [String]
  ancestorIds: [Int!]!
}

enum DeltaFileFlowState {
  IN_FLIGHT
  COMPLETE
  PENDING_ANNOTATIONS
  ERROR
  CANCELLED
}

enum FlowType {
  TIMED_DATA_SOURCE
  REST_DATA_SOURCE
  FLOW
  TRANSFORM # TODO should this be replaced with FLOW
  EGRESS
}

type DeltaFileFlow {
  name: String!
  # unique uuid produced for this deltaFile instantiation, used to reconstruct the DAG
  id: Int!
  type: FlowType!
  state: DeltaFileFlowState!
  created: DateTime!
  modified: DateTime!
  flowPlan: FlowPlanCoordinates!
  input: DeltaFileFlowInput!
  actions: [Action!]!
  publishTopics: [String!]!
  # +1 from the last flow
  depth: Int!
  pendingAnnotations: [String]
  testMode: Boolean!
  testModeReason: String
}

type DeltaFile {
  schemaVersion: Int!
  did: String!
  # optional name assigned by the data source
  name: String
  dataSource: String!
  parentDids: [String!]!
  childDids: [String!]!
  flows: [DeltaFileFlow!]!
  requeueCount: Int!
  ingressBytes: Long!
  referencedBytes: Long!
  totalBytes: Long!
  stage: DeltaFileStage!
  annotations: Metadata
  egressFlows: [String!]!
  created: DateTime!
  modified: DateTime!
  contentDeleted: DateTime
  contentDeletedReason: String
  egressed: Boolean
  filtered: Boolean
  replayed: DateTime
  replayDid: String
}

type DeltaFiles {
  offset: Int
  count: Int
  totalCount: Int
  deltaFiles: [DeltaFile!]!
}

input DeltaFileOrder {
  direction: DeltaFileDirection!
  # The field name is passed directly to the DB for sort
  # this is not ideal, but better than requiring hard-coding every possibility
  field: String!
}

enum DeltaFileDirection {
  ASC
  DESC
}

input ErrorSummaryFilter {
  modifiedAfter: DateTime
  modifiedBefore: DateTime
  errorAcknowledged: Boolean
  flow: String
}

input FilteredSummaryFilter {
  modifiedAfter: DateTime
  modifiedBefore: DateTime
  flow: String
}

type CountPerFlow {
  flow: String!
  count: Int!
  dids: [String!]!
}

type CountPerMessage {
  message: String!
  flow: String!
  count: Int!
  dids: [String!]!
}

type ErrorsByFlow {
  offset: Int!
  count: Int!
  totalCount: Int!
  countPerFlow: [CountPerFlow!]!
}

type ErrorsByMessage {
  offset: Int!
  count: Int!
  totalCount: Int!
  countPerMessage: [CountPerMessage!]!
}

type FilteredByFlow {
  offset: Int!
  count: Int!
  totalCount: Int!
  countPerFlow: [CountPerFlow!]!
}

type FilteredByMessage {
  offset: Int!
  count: Int!
  totalCount: Int!
  countPerMessage: [CountPerMessage!]!
}

input DeltaFilesFilter {
  dids: [String!]
  nameFilter: NameFilter
  parentDid: String
  requeueCountMin: Int
  ingressBytesMin: Long
  ingressBytesMax: Long
  referencedBytesMin: Long
  referencedBytesMax: Long
  totalBytesMin: Long
  totalBytesMax: Long
  createdAfter: DateTime
  createdBefore: DateTime
  annotations: [KeyValueInput!]
  egressFlows: [String!]
  contentDeleted: Boolean
  modifiedAfter: DateTime
  modifiedBefore: DateTime
  stage: DeltaFileStage
  actions: [String!]
  errorCause: String
  filteredCause: String
  errorAcknowledged: Boolean
  egressed: Boolean
  filtered: Boolean
  testMode: Boolean
  replayable: Boolean
  replayed: Boolean
  terminalStage: Boolean
  pendingAnnotations: Boolean
}

type RetryResult {
  did: String!
  success: Boolean!
  error: String
}

type AcknowledgeResult {
  did: String!
  success: Boolean!
  error: String
}

type CancelResult {
  did: String!
  success: Boolean!
  error: String
}

type Result {
  success: Boolean!
  info: [String]
  errors: [String]
}

type DeltaFileStats {
  totalCount: Long!
  inFlightCount: Long!
  inFlightBytes: Long!
}

input ResumeMetadata {
  flow: String!
  action: String!
  metadata: [KeyValueInput!]
  deleteMetadataKeys: [String!]
}

type Query {
  getEgressFlowPlan(planName: String!): EgressFlowPlan!
  getDataSourcePlan(planName: String!): DataSourcePlan!
  getTransformFlowPlan(planName: String!): TransformFlowPlan!
  getEgressFlow(flowName: String!): EgressFlow!
  getDataSource(name: String!): DataSource!
  getTransformFlow(flowName: String!): TransformFlow!
  validateEgressFlow(flowName: String!): EgressFlow!
  validateDataSource(name: String!): DataSource!
  validateTransformFlow(flowName: String!): TransformFlow!
  getFlowNames(state: FlowState): FlowNames!
  getFlows: [Flows]!
  getRunningFlows: SystemFlows!
  getAllFlows: SystemFlows!
  getAllFlowPlans: SystemFlowPlans!
  getActionNamesByFamily: [ActionFamily]!
  ingressFlowErrorsExceeded: [IngressFlowErrorState]!

  deltaFiles(offset: Int, limit: Int, filter: DeltaFilesFilter, orderBy: DeltaFileOrder): DeltaFiles!
  deltaFile(did: String!): DeltaFile
  rawDeltaFile(did: String!, pretty: Boolean): String
  pendingAnnotations(did: String!): [String]!
  lastCreated(last: Int) : [DeltaFile]!
  lastModified(last: Int) : [DeltaFile]!
  lastErrored(last: Int) : [DeltaFile]!
  lastWithName(name: String!) : DeltaFile

  errorSummaryByFlow(offset: Int, limit: Int, filter: ErrorSummaryFilter, orderBy: DeltaFileOrder): ErrorsByFlow!
  errorSummaryByMessage(offset: Int, limit: Int, filter: ErrorSummaryFilter, orderBy: DeltaFileOrder): ErrorsByMessage!

  filteredSummaryByFlow(offset: Int, limit: Int, filter: FilteredSummaryFilter, orderBy: DeltaFileOrder): FilteredByFlow!
  filteredSummaryByMessage(offset: Int, limit: Int, filter: FilteredSummaryFilter, orderBy: DeltaFileOrder): FilteredByMessage!

  errorMetadataUnion(dids: [String!]!) : [PerActionUniqueKeyValues!]!
  sourceMetadataUnion(dids: [String!]!) : [UniqueKeyValues!]!

  deltaFiConfigs(configQuery: ConfigQueryInput) : [DeltaFiConfiguration]!
  actionDescriptors: [ActionDescriptor!]!
  exportConfigAsYaml: String!

  plugins: [Plugin!]!
  verifyActionsAreRegistered(pluginCoordinates: PluginCoordinatesInput!) : Boolean

  annotationKeys: [String!]!

  version: String!
  totalCount: Long
  countUnacknowledgedErrors: Long

  deltaFileStats: DeltaFileStats!
}

type Mutation {
  saveEgressFlowPlan(egressFlowPlan: EgressFlowPlanInput!) : EgressFlow!
  saveTimedDataSourcePlan(dataSourcePlan: TimedDataSourcePlanInput!) : TimedDataSource!
  saveRestDataSourcePlan(dataSourcePlan: RestDataSourcePlanInput!) : RestDataSource!
  saveTransformFlowPlan(transformFlowPlan: TransformFlowPlanInput!) : TransformFlow!
  removeEgressFlowPlan(name: String!) : Boolean!
  removeDataSourcePlan(name: String!) : Boolean!
  removeTransformFlowPlan(name: String!) : Boolean!

  startEgressFlow(flowName: String!) : Boolean!
  startDataSource(name: String!) : Boolean!
  startTransformFlow(flowName: String!) : Boolean!
  stopEgressFlow(flowName: String!) : Boolean!
  stopDataSource(name: String!) : Boolean!
  stopTransformFlow(flowName: String!) : Boolean!

  setMaxErrors(flowName: String!, maxErrors: Int!) : Boolean!
  enableEgressTestMode(flowName: String!) : Boolean!
  disableEgressTestMode(flowName: String!) : Boolean!
  setTimedIngressMemo(name: String!, memo: String) : Boolean!
  setTimedIngressCronSchedule(name: String!, cronSchedule: String!) : Boolean!
  enableDataSourceTestMode(name: String!) : Boolean!
  disableDataSourceTestMode(name: String!) : Boolean!
  enableTransformTestMode(flowName: String!) : Boolean!
  disableTransformTestMode(flowName: String!) : Boolean!
  setEgressFlowExpectedAnnotations(flowName: String!, expectedAnnotations: [String]) : Boolean!

  taskTimedIngress(name: String!, memo: String) : Boolean!
  resume(action: String, dids: [String!]!, resumeMetadata: [ResumeMetadata!]) : [RetryResult!]!
  replay(dids: [String!]!, replaceDeltaFileName: String, replaceDataSource: String, removeSourceMetadata: [String!], replaceSourceMetadata: [KeyValueInput!]) : [RetryResult!]!
  acknowledge(dids: [String!]!, reason: String) : [AcknowledgeResult!]!
  cancel(dids: [String!]!) : [CancelResult!]!

  addAnnotations(did: String!, annotations: [KeyValueInput!]!, allowOverwrites: Boolean!) : Boolean!

  savePluginVariables(variables: [VariableInput]!) : Boolean!
  removePluginVariables: Boolean!
  setPluginVariableValues(pluginCoordinates: PluginCoordinatesInput!, variables: [KeyValueInput!]) : Boolean!

  stressTest(flow: String!, contentSize: Int!, numFiles: Int!, metadata: [KeyValueInput!], batchSize: Int) : Int!
}
