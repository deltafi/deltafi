#!/bin/bash

# KinD Image Sync Script
# This script checks for image hash mismatches between running containers and local images
# and restarts pods when mismatches are detected.

set -euo pipefail

# Script configuration
SCRIPT_NAME=$(basename "$0")
VERSION="1.0.0"

# Default values
NAMESPACE=""
DRY_RUN=false
VERBOSE=false
LOG_LEVEL="INFO"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}       ‣${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}       ⚠${NC} $1"
}

log_error() {
    echo -e "${RED}       ✗${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}       ✓${NC} $1"
}

log_debug() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[DEBUG] ${NC} $1"
    fi
}

# Print usage information
usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Check for image hash mismatches in KinD cluster and restart pods when needed.

OPTIONS:
    -n, --namespace <namespace>    Target namespace (default: all namespaces)
    -d, --dry-run                  Show what would be done without making changes
    -v, --verbose                  Enable verbose output
    -h, --help                     Show this help message
    --version                      Show version information

EXAMPLES:
    $SCRIPT_NAME --namespace default
    $SCRIPT_NAME --dry-run --verbose
    $SCRIPT_NAME --namespace kube-system --dry-run

EOF
}

# Print version information
version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Check if required tools are available
check_dependencies() {
    local missing_tools=()
    
    for tool in crictl jq kubectl; do
        if ! command -v "$tool" &> /dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_error "Please install the missing tools and try again."
        exit 1
    fi
    
    log_debug "All required tools are available"
}

# Check if we're running on a KinD control-plane node
check_environment() {
    if ! command -v crictl &> /dev/null; then
        log_error "crictl not found. This script must run on a KinD control-plane node."
        exit 1
    fi
    
    if ! kubectl cluster-info &> /dev/null; then
        log_error "kubectl cluster-info failed. Please ensure you have access to the cluster."
        exit 1
    fi
    
    log_debug "Environment check passed"
}

# Get running container IDs
get_running_containers() {
    local containers
    local crictl_cmd="crictl ps -o json"
    
    # Add namespace filter if specified
    if [[ -n "$NAMESPACE" ]]; then
        crictl_cmd="$crictl_cmd --namespace $NAMESPACE"
    fi
    
    if ! containers=$($crictl_cmd | jq -r '.containers[].id' 2>/dev/null); then
        return 1
    fi
    
    echo "$containers"
}

# Get container image hash
get_container_image_hash() {
    local container_id="$1"
    
    if ! crictl inspect "$container_id" | jq -r '.info.config.image.image' 2>/dev/null; then
        return 1
    fi
}

# Get container image name
get_container_image_name() {
    local container_id="$1"
    
    if ! crictl inspect "$container_id" | jq -r '.info.config.image.user_specified_image' 2>/dev/null; then
        return 1
    fi
}

# Get local image hash
get_local_image_hash() {
    local image_name="$1"
    
    if ! crictl inspecti "$image_name" | jq -r '.status.id' 2>/dev/null; then
        return 1
    fi
}

# Get pod name from container ID
get_pod_name_from_container() {
    local container_id="$1"
    
    if ! crictl inspect "$container_id" | jq -r '.info.config.labels."io.kubernetes.pod.name"' 2>/dev/null; then
        return 1
    fi
}

# Get pod namespace from container ID
get_pod_namespace_from_container() {
    local container_id="$1"
    
    if ! crictl inspect "$container_id" | jq -r '.info.config.labels."io.kubernetes.pod.namespace"' 2>/dev/null; then
        return 1
    fi
}


# Restart pod
restart_pod() {
    local pod_name="$1"
    local namespace="$2"
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "[DRY-RUN] Would restart pod $pod_name in namespace $namespace"
        return 0
    fi
    
    log_info "Restarting $pod_name"
    
    if kubectl delete pod "$pod_name" -n "$namespace" >/dev/null; then
        log_success "$pod_name ($namespace)"
    else
        log_error "Failed to restart pod $pod_name in namespace $namespace"
        return 1
    fi
}

# Main function to check and restart pods
main() {
    local containers
    local mismatched_pods=()
    local total_containers=0
    local checked_containers=0
    
    log_info "Starting image hash mismatch check"
    if [[ -n "$NAMESPACE" ]]; then
        log_debug "Namespace filter: $NAMESPACE"
    else
        log_debug "Namespace filter: all namespaces"
    fi
    log_debug "Dry run mode: $DRY_RUN"
    
    # Get running containers
    log_debug "Getting running container IDs..."
    containers=$(get_running_containers)
    if [[ $? -ne 0 ]]; then
        log_error "Failed to get running containers"
        return 1
    fi
    
    if [[ -z "$containers" ]]; then
        log_info "No containers to check"
        return 0
    fi
    
    total_containers=$(echo "$containers" | wc -l)
    log_info "Found $total_containers running containers"
    
    # Process each container
    while IFS= read -r container_id; do
        [[ -z "$container_id" ]] && continue
        
        log_debug "Checking container: $container_id"
        
        # Get container information
        local image_hash image_name pod_name local_hash pod_namespace
        
        if ! image_hash=$(get_container_image_hash "$container_id"); then
            log_warn "Skipping container $container_id due to error"
            continue
        fi
        
        if ! image_name=$(get_container_image_name "$container_id"); then
            log_warn "Skipping container $container_id due to error"
            continue
        fi
                
        if ! pod_name=$(get_pod_name_from_container "$container_id"); then
            log_warn "Skipping container $container_id due to error"
            continue
        fi

        if ! pod_namespace=$(get_pod_namespace_from_container "$container_id"); then
            log_warn "Skipping container $container_id due to error"
            continue
        fi

        log_debug "Pod name: $pod_name"
        log_debug "Pod namespace: $pod_namespace"
        log_debug "Image hash: $image_hash"
        log_debug "Image name: $image_name"
        
        checked_containers=$((checked_containers + 1))
        
        # Get local image hash
        if ! local_hash=$(get_local_image_hash "$image_name"); then
            log_warn "Skipping container $container_id due to error getting local image hash"
            continue
        fi
        
        # Compare hashes
        if [[ "$image_hash" != "$local_hash" ]]; then
            log_warn "Hash mismatch detected for pod $pod_name"
            log_debug "  Container image hash: $image_hash"
            log_debug "  Local image hash: $local_hash"
            log_debug "  Image name: $image_name"
            
            mismatched_pods+=("$pod_name:$pod_namespace")
        else
            log_debug "Hash match for pod $pod_name"
        fi
        
    done <<< "$containers"
    
    # Summary
    log_debug "Checked $checked_containers containers"
    log_info "Found ${#mismatched_pods[@]} pods with hash mismatches"
    
    if [[ ${#mismatched_pods[@]} -eq 0 ]]; then
        log_success "No pods need to be restarted"
        return 0
    fi
    
    # Display mismatched pods
    log_debug "Pods with hash mismatches:"
    for pod_info in "${mismatched_pods[@]}"; do
        IFS=':' read -r pod_name namespace <<< "$pod_info"
        log_debug "  - $pod_name (namespace: $namespace)"
    done
    
    # Restart pods if not in dry-run mode
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Dry run mode: No pods were restarted"
        return 0
    fi
    
    # Restart pods
    local restart_errors=0
    for pod_info in "${mismatched_pods[@]}"; do
        IFS=':' read -r pod_name namespace <<< "$pod_info"
        
        if ! restart_pod "$pod_name" "$namespace"; then
            restart_errors=$((restart_errors + 1))
        fi
    done
    
    # Final summary
    if [[ $restart_errors -eq 0 ]]; then
        log_success "All mismatched pods have been restarted successfully"
    else
        log_error "$restart_errors pods failed to restart"
        exit 1
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --version)
            version
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Main execution
trap 'log_error "Script interrupted"; exit 1' INT TERM

check_dependencies
check_environment
main

