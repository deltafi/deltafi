#!/usr/bin/env bash

set -e

cli_help_command() {
  echo "
Command: compose

Subcommands:
  start                       start all of the services
  uninstall                   stop and remove all of the services (destructive to mongo storage)
  restart <services>          restart the list of services (space delimited, restarts all services by default)
  stop-services <services>    stop the list of services (space delimited, stops all services by default)
  build                       build and tag core docker images for use in compose
  destroy                     remove all data directories for DeltaFi
  images                      list a manifest of all images used by the stack
  top                         top listing for compose stack
  logs                        show logs for compose stack
  ps                          show running compose stack
  pause                       pause the compose stack
  unpause                     unpause the compose stack

Usage:
  compose [SUBCOMMAND] [ARGS]

Options:
  -h, --help                          Show help
  "
  exit 1
}

cli_start_help_command() {
  echo "
Command: compose start

Usage:
  compose start <arguments>

  Arguments:
  -f|--values <val>                  specify values in a YAML file (can specify multiple)
  -p|--plugin <PLUGIN NAME>          install plugin (can specify multiple)
  -s|--post-install-script <SCRIPT>  run post-install script (can specify multiple)
  "
  exit 1
}

SUDO=$(which sudo)
export USER_ID
USER_ID=$(id -u)

# _readlink()
#
# Usage:
#   _readlink [-e|-f|<options>] <path/to/symlink>
#
# Options:
#   -f  All but the last component must exist.
#   -e  All components must exist.
#
# Description:
#   Wrapper for `readlink` that provides portable versions of GNU `readlink -f`
#   and `readlink -e`, which canonicalize by following every symlink in every
#   component of the given name recursively.
#
# More Information:
#   http://stackoverflow.com/a/1116890
_readlink() {
  local _target_path
  local _target_file
  local _final_directory
  local _final_path
  local _option

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -e|-f)
        _option="${__arg}"
        ;;
      -*)
        # do nothing
        # ':' is bash no-op
        :
        ;;
      *)
        if [[ -z "${_target_path:-}" ]]
        then
          _target_path="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_option}" ]]
  then
    readlink "${@}"
  else
    if [[ -z "${_target_path:-}" ]]
    then
      printf "_readlink: missing operand\\n"
      return 1
    fi

    cd "$(dirname "${_target_path}")" || return 1
    _target_file="$(basename "${_target_path}")"

    # Iterate down a (possible) chain of symlinks
    while [[ -L "${_target_file}" ]]
    do
      _target_file="$(readlink "${_target_file}")"
      cd "$(dirname "${_target_file}")" || return 1
      _target_file="$(basename "${_target_file}")"
    done

    # Compute the canonicalized name by finding the physical path
    # for the directory we're in and appending the target file.
    _final_directory="$(pwd -P)"
    _final_path="${_final_directory}/${_target_file}"

    if [[ "${_option}" == "-f" ]]
    then
      printf "%s\\n" "${_final_path}"
      return 0
    elif [[ "${_option}" == "-e" ]]
    then
      if [[ -e "${_final_path}" ]]
      then
        printf "%s\\n" "${_final_path}"
        return 0
      else
        return 1
      fi
    else
      return 1
    fi
  fi
}

normal=$(tput sgr0)
bold=$(tput bold)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 33)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
black=$(tput setaf 0)
gray=$(tput setaf 8)
orange=$(tput setaf 208)

_log() {
  local timestamp
  timestamp=${gray}$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "${yellow}>  $timestamp${normal} $1"
}

_attention() {
  {
    printf "\n%s\n\n" "${gray}       ▶ ${blue}${*}${normal}"
  } 1>&2
}

_info() {
  {
    local prepend="${orange} ‣ ${normal}"
    case $1 in
    -w)
      prepend="${red} ‼ ${normal}"
      shift
      ;;
    -h)
      prepend="${yellow} ! ${normal}"
      shift
      ;;
    -s)
      prepend="${blue} ╭ ${normal}"
      shift
      ;;
    -e)
      prepend="${blue} ╰ ${normal}"
      shift
      ;;
    -q)
      prepend="   "
      shift
      ;;
    -a)
      prepend="${blue} │${gray} "
      shift
      ;;
    esac
    printf "      %s\n" "${prepend}${*}${normal}"
  } 1>&2
}

_warn() {
  _info -w "$@"
}

_message() {
  color="$1"
  msg="$2"
  shift 2
  printf "[%s%-4s%s]   %s\n" "$color" "$msg" "${normal}" "$@"
}

_ok_annotated() {
  printf "[%s%-4s%s] ${blue}╰${normal} %s\n" "$green" " OK" "${normal}" "$@"
}

_ok() {
  _message "${green}" " OK " "$@"
}

_down() {
  _message "${yellow}" "DOWN" "$@"
}

_fail() {
  _message "${red}" "FAIL" "$@"
}

_conditional() {
  title=$1
  shift

  if "${@}"; then
    _ok_annotated $title
  else
    _fail $title
    return 1
  fi
}

_annotated_subshell() {

  local filters=()
  while true; do
    case $1 in
    -h)
      _info -s "$2"
      shift 2
      ;;
    -v)
      filters+=("$2")
      shift 2
      ;;
    *)
      break
      ;;
    esac
  done
  {
    "${@}" 2>&1 | while read -r line; do
      local remove=
      for filter in "${filters[@]}"; do
        if [[ $line =~ $filter ]]; then
          remove=true
          continue
        fi
      done
      [[ -n "${remove}" ]] && continue
      _info -a "$line"
    done
  } 2>&1
}

_tool_exists() {
  command -v "$1" &> /dev/null
}

_base64() {
  local TEMPFILE
  if _tool_exists mktemp; then
    TEMPFILE=$(mktemp)
  else
    TEMPFILE=/tmp/base64.foo
    touch $TEMPFILE
  fi

  local BASE64_ARGS=""
  if base64 -i "$TEMPFILE" -w0 > /dev/null 2>&1; then
    BASE64_ARGS="-w0"
  fi

  rm -f "$TEMPFILE"
  base64 $BASE64_ARGS
}

DELTAFI_COMPOSE_PATH=$(cd $(dirname $(_readlink -f $0)) && pwd)
DELTAFI_PATH=$(cd $(dirname $(_readlink -f $0))/.. && pwd)
COMPOSE_FILE="${DELTAFI_COMPOSE_PATH}/docker-compose.yml"
VERSION=$(deltafi version)

# TODO make the data directory configurable
DATA_DIR="${DELTAFI_COMPOSE_PATH}/data"
SETTINGS_DIR="${DELTAFI_COMPOSE_PATH}/settings"
SECRETS_DIR="${SETTINGS_DIR}/secrets"
ENV_DIR="${SETTINGS_DIR}/env"

VALUES_YAML="${ENV_DIR}/values.yaml"
COMMON_SETTINGS="${ENV_DIR}/common.env"
NGINX_SETTINGS="${ENV_DIR}/nginx.env"
STARTUP_SETTINGS="${ENV_DIR}/startup.env"

_is_arm() {
  if [[ $(uname -p) == 'arm' || $(uname -m) == 'aarch64' ]]; then
    return 0
  else
    return 1
  fi
}

OS="$(uname)"
ARCH="$(uname -m)"
if [[ "${OS}" == "Linux" ]]; then
  DELTAFI_ON_LINUX=1
  _ok "Linux environment detected"
elif [[ "${OS}" == "Darwin" ]]; then
  DELTAFI_ON_MACOS=1
  _ok "MacOS environment detected"
else
  _fail "Compose orchestration for DeltaFi is only supported on macOS and Linux."
fi

_is_linux() {
  [[ "${DELTAFI_ON_LINUX}" == 1 ]] && return 0
  return 1
}

_is_macos() {
  [[ "${DELTAFI_ON_MACOS}" == 1 ]] && return 0
  return 1
}

_random_password() {
  local size=${1:-20}
  printf '%s%s%s' "$(printf '%s' $RANDOM | md5sum | head -c 20)" "$(printf '%s' $RANDOM | md5sum | head -c 20)" "$(printf '%s' $RANDOM | md5sum | head -c 20)" | _base64 | head -c "$size"
}

_setup_secrets() {
  GRAFANA_SECRET_PATH="${SECRETS_DIR}/grafana.env"
  MINIO_SECRET_PATH="${SECRETS_DIR}/minio.env"
  MONGODB_SECRET_PATH="${SECRETS_DIR}/mongodb.env"
  VALKEY_SECRET_PATH="${SECRETS_DIR}/valkey.env"
  SSL_SECRET_PATH="${SECRETS_DIR}/ssl.env"
  CLICKHOUSE_SECRET_PATH="${SECRETS_DIR}/clickhouse.env"

  if [[ ! -f "${GRAFANA_SECRET_PATH}" ]]; then
      grafana_password=$(_random_password 16)
      cat <<EOF > "${GRAFANA_SECRET_PATH}"
GF_SECURITY_ADMIN_USER=admin
GF_SECURITY_ADMIN_PASSWORD=$grafana_password
EOF
  fi

  if [[ ! -f "${MINIO_SECRET_PATH}" ]]; then
      minio_password=$(_random_password 40)
      cat <<EOF > "${MINIO_SECRET_PATH}"
MINIO_ROOT_USER=deltafi
MINIO_ROOT_PASSWORD=$minio_password
MINIO_ACCESSKEY=deltafi
MINIO_SECRETKEY=$minio_password
EOF
  fi

  if [[ ! -f "${MONGODB_SECRET_PATH}" ]]; then
    mongo_password=$(_random_password 20)
    mongo_root_password=$(_random_password 20)
    cat <<EOF > "${MONGODB_SECRET_PATH}"
MONGODB_USERNAME=mongouser
MONGODB_DATABASE=deltafi
MONGO_PASSWORD=$mongo_password
MONGODB_PASSWORD=$mongo_password
MONGODB_ROOT_PASSWORD=$mongo_root_password
EOF
  fi

  if [[ ! -f "${VALKEY_SECRET_PATH}" ]]; then
    valkey_password=$(_random_password 16)
    cat <<EOF > "${VALKEY_SECRET_PATH}"
REDIS_PASSWORD=$valkey_password
VALKEY_PASSWORD=$valkey_password
EOF
  fi

  if [[ ! -f "${CLICKHOUSE_SECRET_PATH}" ]]; then
    clickhouse_password=$(_random_password 16)
    cat <<EOF > "${CLICKHOUSE_SECRET_PATH}"
CLICKHOUSE_PASSWORD=$clickhouse_password
CLICKHOUSE_ADMIN_USER=default
CLICKHOUSE_ADMIN_PASSWORD=$clickhouse_password
EOF
  fi

  if [[ ! -f "${CLICKHOUSE_SECRET_PATH}" ]]; then
    clickhouse_password=$(_random_password 16)
    cat <<EOF > "${CLICKHOUSE_SECRET_PATH}"
CLICKHOUSE_PASSWORD=$clickhouse_password
CLICKHOUSE_ADMIN_USER=default
CLICKHOUSE_ADMIN_PASSWORD=$clickhouse_password
EOF
  fi

  # TODO -- SSL settings need to be passed in/read
  if [[ ! -f "${SSL_SECRET_PATH}" ]]; then
    cat <<EOF > "${SSL_SECRET_PATH}"
SSL_KEYSTORE=/etc/pki/keyStore.p12
SSL_KEYSTORETYPE=PKCS12
SSL_KEYSTORE_PASSWORD=not-set
SSL_TRUSTSTORE=/etc/pki/trustStore.jks
SSL_TRUSTSTORETYPE=JKS
SSL_TRUSTSTORE_PASSWORD=not-set
SSL_PROTOCOL=TLSv1.2
EOF
  fi
}

_create_network() {
  if ! docker network ls | grep -q "deltafi"; then
    echo "Creating deltafi network ..."
    docker network create deltafi
  fi
}

_verify_or_replace_fqdn() {
  local FQDN=$1
  if grep -qxF "127.0.0.1 $FQDN" /etc/hosts; then
    _ok "Active: $FQDN"
  else
    echo "127.0.0.1 $FQDN" | ${SUDO} tee -a /etc/hosts > /dev/null
    _ok "Added: $FQDN"
  fi
}

_check_local_fqdns() {
  _info "Checking /etc/hosts config"
  _info -h "You may be prompted for your sudo password"

  domain=$(_from_values ".ingress.domain")
  _verify_or_replace_fqdn "$domain"
  _verify_or_replace_fqdn "graphite.$domain"
  _verify_or_replace_fqdn "minio.$domain"
  _verify_or_replace_fqdn "orchestration.$domain"
  _verify_or_replace_fqdn "deltafi-api-service"
  _verify_or_replace_fqdn "deltafi-auth-service"
  _verify_or_replace_fqdn "deltafi-core-service"
  _verify_or_replace_fqdn "deltafi-ingress-service"
}

# creates a default values yaml using the local repo if this is a snapshot version otherwise it will use docker.io/deltafi
_write_default_values() {
  tag=${VERSION}
  repo="deltafi"

  cat <<EOF > "${VALUES_YAML}"
deltafi:
  core_actions:
    image: ${repo}/deltafi-core-actions:${tag}
  core:
    image: ${repo}/deltafi-core:${tag}
  docs:
    image: ${repo}/deltafi-docs:${tag}
    enabled: true
  ingress:
    image: ${repo}/deltafi-core:${tag}
    envVar:
      HTTP_MAX_BODY_SIZE: 5G
  auth:
    image: ${repo}/deltafi-auth:${tag}
    workers: 8
    mode: disabled # basic, cert, or disabled
    secret: auth-secret
    entityResolver:
      enabled: false
      image: ${repo}/deltafi-entity-resolver:${tag}
      port: 8080
  api:
    image: ${repo}/deltafi-api:${tag}
    workers: 8
  ui:
    image: ${repo}/deltafi-ui:${tag}
  egress_sink:
    enabled: true
    image: ${repo}/deltafi-egress-sink:${tag}
  nodemonitor:
    image: ${repo}/deltafi-nodemonitor:${tag}
  clickhouse:
    enabled: true
  clickhouse_etl:
    enabled: true
    image: ${repo}/deltafi-clickhouse-etl:${tag}
    interval: 120
    lag: 120
    batch: 2000
    delete_ttl: "7 DAY"
# nginx domain
ingress:
  domain: local.deltafi.org
dependencies:
  grafana: deltafi/grafana:11.1.3-0
  graphite: graphiteapp/graphite-statsd:1.1.10-5
  loki: grafana/loki:2.9.9
  minio: quay.io/minio/minio:RELEASE.2024-07-04T14-25-45Z
  nginx: docker.io/nginx:1.27.0-alpine
  promtail: docker.io/grafana/promtail:2.9.9
  mongodb: docker.io/bitnami/mongodb:5.0.17
  valkey: docker.io/bitnami/valkey:7.2.5
  clickhouse: bitnami/clickhouse:24.3.3-debian-12-r2
EOF

  if _is_arm; then
    yq -r -i '.dependencies.mongodb = "zcube/bitnami-compat-mongodb:5.0.17"' "${VALUES_YAML}"
  fi
}

# overlay the values that were passed on top of the default values
_merge_values_yaml() {
  _write_default_values

  if [[ -n "${1}" ]]; then
    for i; do
      echo "Adding values from ${i}"
      if [ ! -f "${i}" ]; then
        echo "${i}: No such file"
        exit 1
      fi
      temp=$(dirname "${VALUES_YAML}")/override.$(basename "${i}")
      cp "${i}" "${temp}"
      yq -r -i '. *= load("'"${temp}"'")' "${VALUES_YAML}"
      rm -f "${temp}"
    done
  fi
}

_append() {
  printf "%s=%s\n" "${1}" "${2}" >> "${3}"
}

_append_common() {
  _append "${1}" "${2}" "${COMMON_SETTINGS}"
}

_append_startup() {
  _append "${1}" "${2}" "${STARTUP_SETTINGS}"
}

_from_values() {
  yq -r "${1}" ${VALUES_YAML}
}

_append_startup_from_values() {
  _append_startup "${1}" "$(_from_values "${2}")" "${STARTUP_SETTINGS}"
}

_append_common_from_values() {
  _append_common "${1}" "$(_from_values "${2}")" "${COMMON_SETTINGS}"
}

_append_compose_profiles() {
  profiles=()
  docs_enabled=$(_from_values ".deltafi.docs.enabled")
  egress_sink_enabled=$(_from_values ".deltafi.egress_sink.enabled")
  entity_resolver_enabled=$(_from_values ".deltafi.auth.entityResolver.enabled")

  if [[ "${docs_enabled}" = "true" ]]; then
    profiles+=("docs")
  fi

  if [[ "${egress_sink_enabled}" = "true" ]]; then
    profiles+=("egress-sink")
  fi

  if [[ "${entity_resolver_enabled}" = "true" ]]; then
    profiles+=("entity-resolver")
  fi

  # TODO - nginx template needs to support disabling these services before the profiles can be used to disable services
  # profile_str=$(local IFS=, ; echo "${profiles[*]}")
  profile_str="docs,egress-sink"
  if [[ -n "${profile_str}" ]]; then
    _append_startup "COMPOSE_PROFILES" "${profile_str}"
  fi
}

# create the startup.env file used by the docker compose commands
_write_startup_file() {
  truncate -s 0 "${STARTUP_SETTINGS}"
  _append_startup "SETTINGS_DIR" "${SETTINGS_DIR}"
  _append_startup "SECRETS_DIR" "${SECRETS_DIR}"
  _append_startup "ENV_DIR" "${ENV_DIR}"
  _append_startup "DATA_DIR" "${DATA_DIR}"
  _append_startup "COMPOSE_PROJECT_NAME" "deltafi"
  if [[ $(_from_values ".deltafi.clickhouse.enabled") == "true" ]]; then
    _append_startup "CLICKHOUSE_SCALE" "1"
  else
    _append_startup "CLICKHOUSE_SCALE" "0"
  fi
  if [[ $(_from_values ".deltafi.clickhouse_etl.enabled") == "true" ]]; then
    _append_startup "CLICKHOUSE_ETL_SCALE" "1"
  else
    _append_startup "CLICKHOUSE_ETL_SCALE" "0"
  fi
  _append_startup_from_values "DELTAFI_API" ".deltafi.api.image"
  _append_startup_from_values "DELTAFI_AUTH" ".deltafi.auth.image"
  _append_startup_from_values "DELTAFI_AUTH_RESOLVER" ".deltafi.auth.entityResolver.image"
  _append_startup_from_values "DELTAFI_CORE" ".deltafi.core.image"
  _append_startup_from_values "DELTAFI_CORE_ACTIONS" ".deltafi.core_actions.image"
  _append_startup_from_values "DELTAFI_DOCS" ".deltafi.docs.image"
  _append_startup_from_values "DELTAFI_EGRESS_SINK" ".deltafi.egress_sink.image"
  _append_startup_from_values "DELTAFI_INGRESS" ".deltafi.ingress.image"
  _append_startup_from_values "DELTAFI_NODEMONITOR" ".deltafi.nodemonitor.image"
  _append_startup_from_values "DELTAFI_UI" ".deltafi.ui.image"
  _append_startup_from_values "DELTAFI_CLICKHOUSE_ETL" ".deltafi.api.image"
  _append_startup_from_values "GRAFANA" ".dependencies.grafana"
  _append_startup_from_values "GRAPHITE" ".dependencies.graphite"
  _append_startup_from_values "LOKI" ".dependencies.loki"
  _append_startup_from_values "MINIO" ".dependencies.minio"
  _append_startup_from_values "MONGODB" ".dependencies.mongodb"
  _append_startup_from_values "NGINX" ".dependencies.nginx"
  _append_startup_from_values "PROMTAIL" ".dependencies.promtail"
  _append_startup_from_values "VALKEY" ".dependencies.valkey"
  _append_startup_from_values "REDIS" ".dependencies.valkey"
  _append_startup_from_values "CLICKHOUSE" ".dependencies.clickhouse"
  _append_startup_from_values "API_WORKERS" ".deltafi.api.workers"
  _append_startup_from_values "AUTH_WORKERS" ".deltafi.auth.workers"
  _append_startup_from_values "AUTH_RESOLVER_PORT" ".deltafi.auth.entityResolver.port"
  _append_compose_profiles
}

# write the static common settings
_write_common_base() {
  cat <<EOF > "${COMMON_SETTINGS}"
CORE_URL=http://deltafi-core:8080/api/v2/
DELTAFI_AUTH_URL=http://deltafi-auth:9292
DELTAFI_GRAFANA_URL=http://deltafi-grafana:3000
DELTAFI_MODE=STANDALONE
GRAPHITE_HOST=deltafi-graphite
GRAPHITE_PORT="2003"
INGRESS_URL=http://deltafi-ingress:8080
PERIOD="9"
METRICS_PERIOD_SECONDS="10"
MINIO_PARTSIZE="5242880"
MINIO_URL=http://deltafi-minio:9000
RACK_ENV=production
VALKEY_URL=http://deltafi-valkey:6379
VALKEY_HOST=deltafi-valkey
VALKEY_PORT=6379
REDIS_URL=http://deltafi-valkey:6379
REDIS_HOST=deltafi-valkey
REDIS_PORT=6379
RUNNING_IN_CLUSTER=false
STATSD_HOSTNAME=deltafi-graphite
STATSD_PORT="8125"
EOF
}

# create the env-files used by the individual services within docker-compose.yaml
_write_env_files() {
  truncate -s 0 "${NGINX_SETTINGS}"

  hostname_value=$(hostname)
  auth_mode=$(_from_values ".deltafi.auth.mode")
  domain=$(_from_values ".ingress.domain")

  _write_common_base
  _append_common "AUTH_MODE" "${auth_mode}"
  _append_common "NODE_NAME" "${hostname_value}"
  _append_common "HOSTNAME" "${hostname_value}"
  _append_common "DELTAFI_UI_DOMAIN" "${domain}"
  _append_common "DOMAIN" "${domain}"

  entity_resolver_port=$(_from_values ".deltafi.auth.entityResolver.port")
  entity_resolver_enabled=$(_from_values ".deltafi.auth.entityResolver.enabled")
  entity_resolver_url="http://deltafi-auth-resolver:${entity_resolver_port}"

  _append_common "ENTITY_RESOLVER_ENABLED" "${entity_resolver_enabled}"
  _append_common "ENTITY_RESOLVER_URL" "${entity_resolver_url}"
  _append_common_from_values "ETL_BATCH" ".deltafi.clickhouse_etl.batch"
  _append_common_from_values "ETL_DELETE_TTL" ".deltafi.clickhouse_etl.delete_ttl"
  _append_common_from_values "ETL_INTERVAL" ".deltafi.clickhouse_etl.interval"
  _append_common_from_values "ETL_LAG" ".deltafi.clickhouse_etl.lag"

  _append_startup_from_values "CLICKHOUSE_ENABLED" ".deltafi.clickhouse.enabled"
  _append_startup_from_values "CLICKHOUSE_ETL_ENABLED" ".deltafi.clickhouse_etl.enabled"
  case "${auth_mode}" in
    disabled)
      auth_request="/no-auth"
      ;;
    basic)
      auth_request="/basic-auth"
      ;;
    cert)
      auth_request="/cert-auth"
      ;;
    *)
      echo "Invalid auth mode - ${auth_mode}"
      exit 1
  esac

  _append "AUTH_REQUEST" "${auth_request}" "${NGINX_SETTINGS}"
  _append "DOMAIN" "${domain}" "${NGINX_SETTINGS}"
}

_write_config() {
  _merge_values_yaml "$@"
  _write_env_files
  _write_startup_file
  _setup_secrets
}

_install_plugins() {
  while [[ $# -gt 0 ]]; do
    plugin="$1"
    shift
    image_tag=${plugin##*/}
    registry=${plugin%/"$image_tag"}
    if [[ "$registry" == "$plugin" ]]; then
      registry="docker.io"
    fi

    echo "Installing plugin: $plugin"
    deltafi install-plugin -i "$registry" "org.deltafi:$image_tag"
    while ! deltafi list-plugins | grep "$image_tag" > /dev/null; do
      echo "- Waiting for ${image_tag} plugin"
      sleep 0.5
    done

    echo "Installed plugin: $plugin"
  done
}

_post_install() {
  while [[ $# -gt 0 ]]; do
    file="$1"
    shift
    if [[ -x "$file" ]]; then
      pwd
      "$file"
    else
      echo "* '${file}' is not an executable file"
    fi
  done
}

_create_data_dirs() {
  mkdir -p "${DATA_DIR}"
  if _is_linux; then
    mkdir -p "${DATA_DIR}"/{mongo,clickhouse,grafana,auth,loki,minio}
  fi
}

start_compose() {
  _create_data_dirs
  _create_network
  _check_local_fqdns
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" up -d
}

uninstall() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" down

  # make sure nothing was left behind (this will sweep up any plugins that weren't part of compose)
  docker ps -a --filter label=deltafi-group -q | xargs docker stop | xargs docker rm

  rm -rf "${DATA_DIR}"/mongo
}

stop_services() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" stop ${1}
}

restart_service() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" up -d --force-recreate --no-deps ${1}
}

images() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" images "$@"
}

top() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" top "$@"
}

ps() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" ps "$@"
}

pause() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" pause "$@"
}

unpause() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" unpause "$@"
}

logs() {
  docker compose --env-file "${STARTUP_SETTINGS}" -f "${COMPOSE_FILE}" logs "$@"
}

clean() {
  rm -rf "${DATA_DIR}" 2&>/dev/null || ${SUDO} rm -rf "${DATA_DIR}"
}

destroy() {
  uninstall
  clean
}

build() {
  _attention "Building DeltaFi core"
  pushd "$DELTAFI_PATH" > /dev/null
  ./gradlew dockerTagDeltafi && _ok "DeltaFi core build successful"
  cd deltafi-ui
  _attention "Building DeltaFi UI"
  docker build -t "deltafi/deltafi-ui:$VERSION" . && _ok "DeltaFi UI build successful"
  popd > /dev/null
} 

ARGS=("$@")
[[ ${#ARGS[@]} -lt 1 ]] && cli_help_command
SUBCOMMAND=${ARGS[0]}
shift

case "$SUBCOMMAND" in
  restart)
    SERVICES=""
    for i
      do SERVICES="${SERVICES} ${i}"
    done
    restart_service "${SERVICES}"
    ;;
  start)
    config_files=()
    post_install_files=()
    plugins=()
    while [[ $# -gt 0 ]]; do
      key="$1"
      case $key in
        -f|--values)
          shift
          config_files+=("$1")
          shift
          ;;
        -p|--plugin)
          shift
          plugins+=("$1")
          shift
          ;;
        -s|--post-install-script)
          shift
          post_install_files+=("$1")
          shift
          ;;
        -h|--help)
          cli_start_help_command
          ;;
        *)
          # skip over anything else
          shift
          ;;
      esac
    done

    _write_config "${config_files[@]}"
    start_compose
    _install_plugins "${plugins[@]}"
    _post_install "${post_install_files[@]}"
    ;;
  uninstall)
    uninstall
    ;;
  images)
    images "$@"
    ;;
  top)
    top "$@"
    ;;
  logs)
    logs "$@"
    ;;
  ps)
    ps "$@"
    ;;
  pause)
    pause "$@"
    ;;
  unpause)
    unpause "$@"
    ;;
  destroy)
    destroy
    ;;
  stop-services)
    SERVICES=""
    for i
      do SERVICES="${SERVICES} ${i}"
    done
    stop_services "${SERVICES}"
    ;;
  build)
    build
    ;;
  *)
    cli_help_command
    ;;

esac
