import java.util.concurrent.TimeUnit

buildscript {
    dependencies {
        classpath "org.yaml:snakeyaml:2.3"
    }
}

plugins {
    id 'org.deltafi.test-summary' version '1.0'
    id 'org.deltafi.git-version' version '2.0.1'
    id 'io.github.gradle-nexus.publish-plugin' version '1.1.0'
    id "de.undercouch.download" version "5.6.0"
}

// Distribution configuration

ext {
    // Base distribution directory
    distroOutputDir = layout.buildDirectory.dir('dist')

    // Common files/directories included in all distributions
    commonDistroContents = [
        [source: 'VERSION', destination: '.'],
        [source: 'CHANGELOG.md', destination: '.'],
        [source: 'README.md', destination: '.'],
        [source: 'LICENSE', destination: '.'],
        [source: 'deltafi-cli/', destination: 'deltafi-cli'],
        [source: 'orchestration/', destination: 'orchestration'],
        [source: 'deltafi-docs/public/docs/', destination: 'docs']
    ]

    // Paths to exclude from all distributions
    excludePaths = [
        '**/data/**',
        '**/logs/**',
        '**/compose/settings/env/common.env',
        '**/compose/settings/env/startup.env',
    ]

    // Architecture-specific files/directories
    archDistroContents = [
        'linux-amd64': [
            // [source: layout.buildDirectory.file('jq-linux-amd64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'jq'
            // ],
            // [source: layout.buildDirectory.file('yq_linux_amd64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'yq'
            // ],
            // [source: layout.buildDirectory.file('lazydocker/linux/amd64/lazydocker').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            // ],
            // [source: layout.buildDirectory.file('lazydocker/linux/amd64/LICENSE').orNull,
            //     destination: 'bin',
            //     rename: 'LICENSE.lazydocker',
            // ],
            [source: 'tui/dist/linux/amd64', destination: '.', topLevel: true]
        ],
        'linux-arm64': [
            // [source: layout.buildDirectory.file('jq-linux-arm64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'jq'
            // ],
            // [source: layout.buildDirectory.file('yq_linux_arm64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'yq'
            // ],
            // [source: layout.buildDirectory.file('lazydocker/linux/arm64/lazydocker').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            // ],
            // [source: layout.buildDirectory.file('lazydocker/linux/arm64/LICENSE').orNull,
            //     destination: 'bin',
            //     rename: 'LICENSE.lazydocker',
            // ],
            [source: 'tui/dist/linux/arm64', destination: '.', topLevel: true]
        ],
        'darwin-amd64': [
            // [source: layout.buildDirectory.file('jq-macos-amd64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'jq'
            // ],
            // [source: layout.buildDirectory.file('yq_darwin_amd64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'yq'
            // ],
            // [source: layout.buildDirectory.file('lazydocker/darwin/amd64/lazydocker').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            // ],
            // [source: layout.buildDirectory.file('lazydocker/darwin/amd64/LICENSE').orNull,
            //     destination: 'bin',
            //     rename: 'LICENSE.lazydocker',
            // ],
            [source: 'tui/dist/darwin/amd64', destination: '.', topLevel: true]
        ],
        'darwin-arm64': [
            // [source: layout.buildDirectory.file('jq-macos-arm64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'jq'
            // ],
            // [source: layout.buildDirectory.file('yq_darwin_arm64').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            //     rename: 'yq'
            // ],
            // [source: layout.buildDirectory.file('lazydocker/darwin/arm64/lazydocker').orNull,
            //     destination: 'bin',
            //     mode: 0755,
            // ],
            // [source: layout.buildDirectory.file('lazydocker/darwin/arm64/LICENSE').orNull,
            //     destination: 'bin',
            //     rename: 'LICENSE.lazydocker',
            // ],
            [source: 'tui/dist/darwin/arm64', destination: '.', topLevel: true]
        ]
    ]
}

// Pretty print maps
import groovy.json.JsonBuilder
java.util.LinkedHashMap.metaClass.pprint = { -> new JsonBuilder(delegate).toPrettyString() }

import org.yaml.snakeyaml.Yaml
def loadDeltafiConfig() {
    def retval = [:];

    def homeDir = System.getenv('HOME');
    File testFile = new File(homeDir + '/.deltafi/config.yaml');

    if ( testFile.isFile() ) {
        retval = new Yaml().load(testFile.newInputStream());
        println ('Loaded configuration from ' + testFile.getPath());
    } else {
        println ('WARNING: ' + testFile.getPath() + ' not found');
    }
    retval = retval ?: [:]

    if (! retval.isEmpty()) println(retval.pprint());

    return retval;
}
ext.deltafiConfig = loadDeltafiConfig();

// Create base distribution task
task dist {
    group = 'distribution'
    description = 'Creates distribution archives for all supported architectures'
    dependsOn 'distBinaries'
}

task distBinaries(type: Download) {
    src([
        // 'https://github.com/jesseduffield/lazydocker/releases/download/v0.24.2/lazydocker_0.24.2_Darwin_arm64.tar.gz',
        // 'https://github.com/jesseduffield/lazydocker/releases/download/v0.24.2/lazydocker_0.24.2_Darwin_x86_64.tar.gz',
        // 'https://github.com/jesseduffield/lazydocker/releases/download/v0.24.2/lazydocker_0.24.2_Linux_arm64.tar.gz',
        // 'https://github.com/jesseduffield/lazydocker/releases/download/v0.24.2/lazydocker_0.24.2_Linux_x86_64.tar.gz',
        // 'https://github.com/mikefarah/yq/releases/download/v4.48.2/yq_linux_arm64',
        // 'https://github.com/mikefarah/yq/releases/download/v4.48.2/yq_linux_amd64',
        // 'https://github.com/mikefarah/yq/releases/download/v4.48.2/yq_darwin_arm64',
        // 'https://github.com/mikefarah/yq/releases/download/v4.48.2/yq_darwin_amd64',
        // 'https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-macos-amd64',
        // 'https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-macos-arm64',
        // 'https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-linux-amd64',
        // 'https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-linux-arm64'
    ])
    dest layout.buildDirectory

    finalizedBy 'decompressDistBinaries'
}

def pathToCamelCase(String path) {
    return path.split(File.separator).collect { String part ->
        part[0].toUpperCase() + part.substring(1)
    }.join('')
}

task decompressDistBinaries {
    group = 'distribution'
    description = 'Decompress the distribution binaries'
}

// [ [ source: 'lazydocker_0.24.2_Darwin_arm64.tar.gz', destination: 'lazydocker/darwin/arm64' ],
//   [ source: 'lazydocker_0.24.2_Darwin_x86_64.tar.gz', destination: 'lazydocker/darwin/amd64' ],
//   [ source: 'lazydocker_0.24.2_Linux_arm64.tar.gz', destination: 'lazydocker/linux/arm64' ],
//   [ source: 'lazydocker_0.24.2_Linux_x86_64.tar.gz', destination: 'lazydocker/linux/amd64' ] ].each { archive ->
//     task "extract${pathToCamelCase(archive.destination)}" (type: Copy) {
//         from tarTree(layout.buildDirectory.file(archive.source))
//         into layout.buildDirectory.file(archive.destination)
//         dependsOn 'distBinaries'
//     }
//     decompressDistBinaries.dependsOn "extract${pathToCamelCase(archive.destination)}"
// }


task tui {
    group = 'build'
    description = 'Build the TUI for the current architecture'
}

task checkDockerInstallation {
    doLast {
        description = 'Checks if docker is installed'
        group = 'verification'
        def command = "command -v docker"
        def result = exec {
            ignoreExitValue = true
            executable "bash"
            args "-l", "-c", command
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
        }

        if (result.exitValue != 0) {
            println "âœ— docker is not installed or not in PATH"
            throw new GradleException("docker is required but not installed")
        }
    }
}

task installPrerequisites {
    group = 'install'
    description = 'Execute any prerequisites prior to install tasks for the current orchestration mode'
    dependsOn tui
    dependsOn checkDockerInstallation
}

task grypeReport {
    group = 'verification'
    description = 'Runs grype on all Docker images and displays a combined summary'
    
    // Depend on all grype tasks from projects that build docker images
    def dockerProjects = ['deltafi-core', 'deltafi-core-actions', 'deltafi-dirwatcher', 'deltafi-egress-sink', 'deltafi-nodemonitor']
    dockerProjects.each { projectName ->
        try {
            dependsOn ":${projectName}:grype"
        } catch (Exception e) {
            // Project or task might not exist, ignore
        }
    }
    
    doLast {
        def resultsDir = layout.buildDirectory.dir("grype-results").get().asFile
        if (!resultsDir.exists() || !resultsDir.isDirectory()) {
            println "\nNo grype results found. Run individual grype tasks first."
            return
        }
        
        def resultFiles = resultsDir.listFiles({ file -> file.name.endsWith('-grype-results.json') } as FileFilter)
        if (resultFiles == null || resultFiles.length == 0) {
            println "\nNo grype results found. Run individual grype tasks first."
            return
        }
        
        def allResults = []
        def totalVulnerabilities = 0
        def totalFixable = 0
        def combinedSeverityCounts = [:]
        
        resultFiles.each { file ->
            try {
                def json = new groovy.json.JsonSlurper().parseText(file.text)
                allResults.add(json)
                totalVulnerabilities += json.totalVulnerabilities ?: 0
                totalFixable += json.fixableCount ?: 0
                
                // Combine severity counts
                if (json.severityCounts) {
                    json.severityCounts.each { severity, count ->
                        combinedSeverityCounts[severity] = (combinedSeverityCounts[severity] ?: 0) + count
                    }
                }
            } catch (Exception e) {
                println "Warning: Could not parse ${file.name}: ${e.message}"
            }
        }
        
        // Display combined summary
        def separator = "=================================================================================="
        println "\n" + separator
        println "COMBINED GRYPE SCAN SUMMARY"
        println separator
        println "Scanned ${allResults.size()} image(s)"
        println "Total vulnerabilities found: ${totalVulnerabilities}"
        
        if (combinedSeverityCounts.size() > 0) {
            println "\nVulnerabilities by severity (combined):"
            def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
            severityOrder.each { severity ->
                if (combinedSeverityCounts.containsKey(severity)) {
                    println "  ${severity.padRight(12)}: ${combinedSeverityCounts[severity]}"
                }
            }
            // Show any severities not in the standard order
            combinedSeverityCounts.each { severity, count ->
                if (!severityOrder.contains(severity)) {
                    println "  ${severity.padRight(12)}: ${count}"
                }
            }
        }
        
        if (totalFixable > 0) {
            println "\nTotal fixable vulnerabilities: ${totalFixable}"
        }
        
        println "\nPer-image breakdown:"
        allResults.sort { it.projectName }.each { result ->
            println "\n  ${result.projectName}:"
            println "    Image: ${result.imageName}"
            println "    Total: ${result.totalVulnerabilities}"
            if (result.severityCounts && result.severityCounts.size() > 0) {
                def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                def severityLine = severityOrder.findAll { result.severityCounts.containsKey(it) }
                    .collect { "${it}:${result.severityCounts[it]}" }
                    .join(", ")
                if (severityLine) {
                    println "    Severities: ${severityLine}"
                }
            }
            if (result.fixableCount > 0) {
                println "    Fixable: ${result.fixableCount}"
                
                // Display fixable vulnerabilities list
                if (result.fixableVulnerabilities && result.fixableVulnerabilities.size() > 0) {
                    println "    Fixable vulnerabilities:"
                    // Sort by severity (Critical first) then by vulnerability ID
                    def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                    def sortedFixable = result.fixableVulnerabilities.sort { vuln ->
                        def severityIndex = severityOrder.indexOf(vuln.severity ?: "Unknown")
                        if (severityIndex == -1) severityIndex = 999
                        [severityIndex, vuln.id ?: ""]
                    }
                    
                    sortedFixable.each { vuln ->
                        def pkgInfo = "${vuln.package}:${vuln.version}"
                        def fixInfo = vuln.fixVersion ? " -> ${vuln.fixVersion}" : ""
                        println "      [${vuln.severity.padRight(9)}] ${vuln.id.padRight(20)} ${pkgInfo.padRight(40)}${fixInfo}"
                    }
                }
            }
        }
        
        println "\n" + separator + "\n"
    }
}

task grypeFullReport {
    group = 'verification'
    description = 'Runs install, then scans all DeltaFi images with grype and displays a combined summary'
    dependsOn 'install'
    
    // Always run, never cache
    outputs.upToDateWhen { false }
    outputs.cacheIf { false }
    
    doLast {
        // Get list of images from deltafi versions command
        // Use a script approach to avoid escaping issues
        def scriptFile = File.createTempFile("grype-images", ".sh")
        scriptFile.text = """#!/bin/bash
deltafi versions --plain --brief | awk '{ print \$3 }' | grep -v '^Image\$'
"""
        scriptFile.setExecutable(true)
        
        def versionsOutput = new ByteArrayOutputStream()
        def versionsError = new ByteArrayOutputStream()
        def versionsResult = exec {
            ignoreExitValue = true
            executable "bash"
            args scriptFile.absolutePath
            standardOutput = versionsOutput
            errorOutput = versionsError
        }
        
        // Clean up temp file
        scriptFile.delete()
        
        if (versionsResult.exitValue != 0) {
            throw new GradleException("Failed to get image list from deltafi versions: ${versionsError.toString()}")
        }
        
        def imageList = versionsOutput.toString().trim().split('\n').findAll { it.trim().length() > 0 }
        
        if (imageList.isEmpty()) {
            println "\nNo images found. Make sure DeltaFi is installed and running."
            return
        }
        
        println "\nFound ${imageList.size()} image(s) to scan:"
        imageList.each { println "  - ${it}" }
        println ""
        
        // Check if grype is available locally or via Docker
        def checkResult = exec {
            ignoreExitValue = true
            executable "bash"
            args "-c", "command -v grype"
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
        }
        
        def useContainer = (checkResult.exitValue != 0)
        def grypeCmd = useContainer ? "docker" : "grype"
        def grypeImage = "anchore/grype:latest"
        
        if (useContainer) {
            // Check if docker is available
            def dockerCheck = exec {
                ignoreExitValue = true
                executable "bash"
                args "-c", "command -v docker"
                standardOutput = new ByteArrayOutputStream()
                errorOutput = new ByteArrayOutputStream()
            }
            
            if (dockerCheck.exitValue != 0) {
                throw new GradleException("grype is not installed and docker is not available. Please install grype or docker.")
            }
            
            println "grype not found locally, using Docker container: ${grypeImage}\n"
        }
        
        // Helper function to build grype command
        def buildGrypeArgs = { args ->
            if (useContainer) {
                def dockerSocket = "/var/run/docker.sock"
                def osName = System.getProperty("os.name").toLowerCase()
                if (osName.contains("windows")) {
                    dockerSocket = "//var/run/docker.sock"
                }
                return ["run", "--rm", "-v", "${dockerSocket}:/var/run/docker.sock", grypeImage] + args
            } else {
                return args
            }
        }
        
        // Update grype database once
        println "Updating grype database..."
        exec {
            executable grypeCmd
            args buildGrypeArgs(["db", "update"])
        }
        println ""
        
        def resultsDir = layout.buildDirectory.dir("grype-results").get().asFile
        resultsDir.mkdirs()
        
        def allResults = []
        
        // Scan each image
        imageList.eachWithIndex { imageName, index ->
            println "Scanning image ${index + 1}/${imageList.size()}: ${imageName}"
            
            // Run grype with JSON output
            def jsonOutput = new ByteArrayOutputStream()
            def jsonError = new ByteArrayOutputStream()
            def jsonResult = exec {
                ignoreExitValue = true
                executable grypeCmd
                args buildGrypeArgs([imageName, "--output", "json"])
                standardOutput = jsonOutput
                errorOutput = jsonError
            }
            
            // Run grype with table output for user to see
            exec {
                ignoreExitValue = true
                executable grypeCmd
                args buildGrypeArgs([imageName])
            }
            
            // Parse JSON and store results
            if (jsonOutput.size() > 0) {
                try {
                    def json = new groovy.json.JsonSlurper().parseText(jsonOutput.toString())
                    def matches = json.matches ?: []
                    
                    // Count vulnerabilities by severity and collect fixable vulnerabilities
                    def severityCounts = [:]
                    def fixableCount = 0
                    def fixableVulnerabilities = []
                    
                    matches.each { match ->
                        def severity = match.vulnerability?.severity ?: "Unknown"
                        severityCounts[severity] = (severityCounts[severity] ?: 0) + 1
                        
                        if (match.vulnerability?.fix?.versions && !match.vulnerability.fix.versions.isEmpty()) {
                            fixableCount++
                            fixableVulnerabilities.add([
                                id: match.vulnerability?.id ?: "Unknown",
                                severity: severity,
                                package: match.artifact?.name ?: "Unknown",
                                version: match.artifact?.version ?: "Unknown",
                                fixVersion: match.vulnerability?.fix?.versions?.get(0) ?: "Unknown",
                                description: match.vulnerability?.description ?: ""
                            ])
                        }
                    }
                    
                    // Extract image name without tag for display
                    def imageDisplayName = imageName.split(':')[0]
                    def imageTag = imageName.contains(':') ? imageName.split(':')[1] : "latest"
                    
                    def result = [
                        projectName: imageDisplayName,
                        imageName: imageName,
                        totalVulnerabilities: matches.size(),
                        severityCounts: severityCounts,
                        fixableCount: fixableCount,
                        fixableVulnerabilities: fixableVulnerabilities
                    ]
                    
                    allResults.add(result)
                    
                    // Save individual result file
                    def resultsFile = new File(resultsDir, "${imageDisplayName.replaceAll('/', '_')}-grype-results.json")
                    resultsFile.text = new groovy.json.JsonBuilder(result).toPrettyString()
                    
                    // Display individual summary
                    def separator = "=================================================================================="
                    println "\n" + separator
                    println "GRYPE SCAN SUMMARY"
                    println separator
                    println "Image: ${imageName}"
                    println "Total vulnerabilities found: ${matches.size()}"
                    
                    if (severityCounts.size() > 0) {
                        println "\nVulnerabilities by severity:"
                        def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                        severityOrder.each { severity ->
                            if (severityCounts.containsKey(severity)) {
                                println "  ${severity.padRight(12)}: ${severityCounts[severity]}"
                            }
                        }
                        severityCounts.each { severity, count ->
                            if (!severityOrder.contains(severity)) {
                                println "  ${severity.padRight(12)}: ${count}"
                            }
                        }
                    }
                    
                    if (fixableCount > 0) {
                        println "\nFixable vulnerabilities: ${fixableCount}"
                    }
                    
                    println separator + "\n"
                    
                } catch (Exception e) {
                    println "\nWarning: Could not parse grype JSON output for ${imageName}: ${e.message}\n"
                }
            }
        }
        
        // Generate combined summary
        if (allResults.isEmpty()) {
            println "\nNo scan results to summarize."
            return
        }
        
        def totalVulnerabilities = 0
        def totalFixable = 0
        def combinedSeverityCounts = [:]
        
        allResults.each { result ->
            totalVulnerabilities += result.totalVulnerabilities ?: 0
            totalFixable += result.fixableCount ?: 0
            
            if (result.severityCounts) {
                result.severityCounts.each { severity, count ->
                    combinedSeverityCounts[severity] = (combinedSeverityCounts[severity] ?: 0) + count
                }
            }
        }
        
        // Build combined summary string
        def separator = "=================================================================================="
        def summary = new StringBuilder()
        summary.append("\n").append(separator).append("\n")
        summary.append("COMBINED GRYPE SCAN SUMMARY").append("\n")
        summary.append(separator).append("\n")
        summary.append("Scanned ${allResults.size()} image(s)").append("\n")
        summary.append("Total vulnerabilities found: ${totalVulnerabilities}").append("\n")
        
        if (combinedSeverityCounts.size() > 0) {
            summary.append("\nVulnerabilities by severity (combined):").append("\n")
            def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
            severityOrder.each { severity ->
                if (combinedSeverityCounts.containsKey(severity)) {
                    summary.append("  ${severity.padRight(12)}: ${combinedSeverityCounts[severity]}").append("\n")
                }
            }
            combinedSeverityCounts.each { severity, count ->
                if (!severityOrder.contains(severity)) {
                    summary.append("  ${severity.padRight(12)}: ${count}").append("\n")
                }
            }
        }
        
        if (totalFixable > 0) {
            summary.append("\nTotal fixable vulnerabilities: ${totalFixable}").append("\n")
        }
        
        summary.append("\nPer-image breakdown:").append("\n")
        allResults.sort { it.projectName }.each { result ->
            summary.append("\n  ${result.projectName}:").append("\n")
            summary.append("    Image: ${result.imageName}").append("\n")
            summary.append("    Total: ${result.totalVulnerabilities}").append("\n")
            if (result.severityCounts && result.severityCounts.size() > 0) {
                def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                def severityLine = severityOrder.findAll { result.severityCounts.containsKey(it) }
                    .collect { "${it}:${result.severityCounts[it]}" }
                    .join(", ")
                if (severityLine) {
                    summary.append("    Severities: ${severityLine}").append("\n")
                }
            }
            if (result.fixableCount > 0) {
                summary.append("    Fixable: ${result.fixableCount}").append("\n")
                
                // Display fixable vulnerabilities list
                if (result.fixableVulnerabilities && result.fixableVulnerabilities.size() > 0) {
                    summary.append("    Fixable vulnerabilities:").append("\n")
                    def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                    def sortedFixable = result.fixableVulnerabilities.sort { vuln ->
                        def severityIndex = severityOrder.indexOf(vuln.severity ?: "Unknown")
                        if (severityIndex == -1) severityIndex = 999
                        [severityIndex, vuln.id ?: ""]
                    }
                    
                    sortedFixable.each { vuln ->
                        def pkgInfo = "${vuln.package}:${vuln.version}"
                        def fixInfo = vuln.fixVersion ? " -> ${vuln.fixVersion}" : ""
                        summary.append("      [${vuln.severity.padRight(9)}] ${vuln.id.padRight(20)} ${pkgInfo.padRight(40)}${fixInfo}").append("\n")
                    }
                }
            }
        }
        
        summary.append("\n").append(separator).append("\n")
        
        // Display summary to console
        println summary.toString()
        
        // Write summary to file
        def scanFile = layout.buildDirectory.file("grype.scan.txt").get().asFile
        scanFile.text = summary.toString()
        println "Scan summary written to: ${scanFile.absolutePath}"
    }
}

task trivyReport {
    group = 'verification'
    description = 'Runs trivy on all Docker images and displays a combined summary'
    
    // Depend on all trivy tasks from projects that build docker images
    def dockerProjects = ['deltafi-core', 'deltafi-core-actions', 'deltafi-dirwatcher', 'deltafi-egress-sink', 'deltafi-nodemonitor']
    dockerProjects.each { projectName ->
        try {
            dependsOn ":${projectName}:trivy"
        } catch (Exception e) {
            // Project or task might not exist, ignore
        }
    }
    
    doLast {
        def resultsDir = layout.buildDirectory.dir("trivy-results").get().asFile
        if (!resultsDir.exists() || !resultsDir.isDirectory()) {
            println "\nNo trivy results found. Run individual trivy tasks first."
            return
        }
        
        def resultFiles = resultsDir.listFiles({ file -> file.name.endsWith('-trivy-results.json') } as FileFilter)
        if (resultFiles == null || resultFiles.length == 0) {
            println "\nNo trivy results found. Run individual trivy tasks first."
            return
        }
        
        def allResults = []
        def totalVulnerabilities = 0
        def totalFixable = 0
        def combinedSeverityCounts = [:]
        
        resultFiles.each { file ->
            try {
                def json = new groovy.json.JsonSlurper().parseText(file.text)
                allResults.add(json)
                totalVulnerabilities += json.totalVulnerabilities ?: 0
                totalFixable += json.fixableCount ?: 0
                
                // Combine severity counts
                if (json.severityCounts) {
                    json.severityCounts.each { severity, count ->
                        combinedSeverityCounts[severity] = (combinedSeverityCounts[severity] ?: 0) + count
                    }
                }
            } catch (Exception e) {
                println "Warning: Could not parse ${file.name}: ${e.message}"
            }
        }
        
        // Display combined summary
        def separator = "=================================================================================="
        println "\n" + separator
        println "COMBINED TRIVY SCAN SUMMARY"
        println separator
        println "Scanned ${allResults.size()} image(s)"
        println "Total vulnerabilities found: ${totalVulnerabilities}"
        
        if (combinedSeverityCounts.size() > 0) {
            println "\nVulnerabilities by severity (combined):"
            def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
            severityOrder.each { severity ->
                if (combinedSeverityCounts.containsKey(severity)) {
                    println "  ${severity.padRight(12)}: ${combinedSeverityCounts[severity]}"
                }
            }
            // Show any severities not in the standard order
            combinedSeverityCounts.each { severity, count ->
                if (!severityOrder.contains(severity)) {
                    println "  ${severity.padRight(12)}: ${count}"
                }
            }
        }
        
        if (totalFixable > 0) {
            println "\nTotal fixable vulnerabilities: ${totalFixable}"
        }
        
        println "\nPer-image breakdown:"
        allResults.sort { it.projectName }.each { result ->
            println "\n  ${result.projectName}:"
            println "    Image: ${result.imageName}"
            println "    Total: ${result.totalVulnerabilities}"
            if (result.severityCounts && result.severityCounts.size() > 0) {
                def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                def severityLine = severityOrder.findAll { result.severityCounts.containsKey(it) }
                    .collect { "${it}:${result.severityCounts[it]}" }
                    .join(", ")
                if (severityLine) {
                    println "    Severities: ${severityLine}"
                }
            }
            if (result.fixableCount > 0) {
                println "    Fixable: ${result.fixableCount}"
                
                // Display fixable vulnerabilities list
                if (result.fixableVulnerabilities && result.fixableVulnerabilities.size() > 0) {
                    println "    Fixable vulnerabilities:"
                    // Sort by severity (Critical first) then by vulnerability ID
                    def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                    def sortedFixable = result.fixableVulnerabilities.sort { vuln ->
                        def severityIndex = severityOrder.indexOf(vuln.severity ?: "Unknown")
                        if (severityIndex == -1) severityIndex = 999
                        [severityIndex, vuln.id ?: ""]
                    }
                    
                    sortedFixable.each { vuln ->
                        def pkgInfo = "${vuln.package}:${vuln.version}"
                        def fixInfo = vuln.fixVersion ? " -> ${vuln.fixVersion}" : ""
                        println "      [${vuln.severity.padRight(9)}] ${vuln.id.padRight(20)} ${pkgInfo.padRight(40)}${fixInfo}"
                    }
                }
            }
        }
        
        println "\n" + separator + "\n"
    }
}

task trivyFullReport {
    group = 'verification'
    description = 'Runs install, then scans all DeltaFi images with trivy and displays a combined summary'
    dependsOn 'install'
    
    // Always run, never cache
    outputs.upToDateWhen { false }
    outputs.cacheIf { false }
    
    doLast {
        // Get list of images from deltafi versions command
        // Use a script approach to avoid escaping issues
        def scriptFile = File.createTempFile("trivy-images", ".sh")
        scriptFile.text = """#!/bin/bash
deltafi versions --plain --brief | awk '{ print \$3 }' | grep -v '^Image\$'
"""
        scriptFile.setExecutable(true)
        
        def versionsOutput = new ByteArrayOutputStream()
        def versionsError = new ByteArrayOutputStream()
        def versionsResult = exec {
            ignoreExitValue = true
            executable "bash"
            args scriptFile.absolutePath
            standardOutput = versionsOutput
            errorOutput = versionsError
        }
        
        // Clean up temp file
        scriptFile.delete()
        
        if (versionsResult.exitValue != 0) {
            throw new GradleException("Failed to get image list from deltafi versions: ${versionsError.toString()}")
        }
        
        def imageList = versionsOutput.toString().trim().split('\n').findAll { it.trim().length() > 0 }
        
        if (imageList.isEmpty()) {
            println "\nNo images found. Make sure DeltaFi is installed and running."
            return
        }
        
        println "\nFound ${imageList.size()} image(s) to scan:"
        imageList.each { println "  - ${it}" }
        println ""
        
        // Check if trivy is available locally or via Docker
        def checkResult = exec {
            ignoreExitValue = true
            executable "bash"
            args "-c", "command -v trivy"
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
        }
        
        def useContainer = (checkResult.exitValue != 0)
        def trivyCmd = useContainer ? "docker" : "trivy"
        def trivyImage = "aquasec/trivy:latest"
        
        if (useContainer) {
            // Check if docker is available
            def dockerCheck = exec {
                ignoreExitValue = true
                executable "bash"
                args "-c", "command -v docker"
                standardOutput = new ByteArrayOutputStream()
                errorOutput = new ByteArrayOutputStream()
            }
            
            if (dockerCheck.exitValue != 0) {
                throw new GradleException("trivy is not installed and docker is not available. Please install trivy or docker.")
            }
            
            println "trivy not found locally, using Docker container: ${trivyImage}\n"
        }
        
        // Helper function to build trivy command
        def buildTrivyArgs = { args ->
            if (useContainer) {
                def dockerSocket = "/var/run/docker.sock"
                def osName = System.getProperty("os.name").toLowerCase()
                if (osName.contains("windows")) {
                    dockerSocket = "//var/run/docker.sock"
                }
                return ["run", "--rm", "-v", "${dockerSocket}:/var/run/docker.sock", trivyImage, "image"] + args
            } else {
                return ["image"] + args
            }
        }
        
        def resultsDir = layout.buildDirectory.dir("trivy-results").get().asFile
        resultsDir.mkdirs()
        
        def allResults = []
        
        // Scan each image
        imageList.eachWithIndex { imageName, index ->
            println "Scanning image ${index + 1}/${imageList.size()}: ${imageName}"
            
            // Run trivy with JSON output
            def jsonOutput = new ByteArrayOutputStream()
            def jsonError = new ByteArrayOutputStream()
            def jsonResult = exec {
                ignoreExitValue = true
                executable trivyCmd
                args buildTrivyArgs(["--format", "json", imageName])
                standardOutput = jsonOutput
                errorOutput = jsonError
            }
            
            // Run trivy with table output for user to see
            exec {
                ignoreExitValue = true
                executable trivyCmd
                args buildTrivyArgs([imageName])
            }
            
            // Parse JSON and store results
            if (jsonOutput.size() > 0) {
                try {
                    def json = new groovy.json.JsonSlurper().parseText(jsonOutput.toString())
                    def vulnerabilities = []
                    
                    // Trivy JSON structure: { "Results": [{ "Vulnerabilities": [...] }] }
                    if (json.Results) {
                        json.Results.each { result ->
                            if (result.Vulnerabilities) {
                                vulnerabilities.addAll(result.Vulnerabilities)
                            }
                        }
                    }
                    
                    // Count vulnerabilities by severity and collect fixable vulnerabilities
                    def severityCounts = [:]
                    def fixableCount = 0
                    def fixableVulnerabilities = []
                    
                    vulnerabilities.each { vuln ->
                        def severity = vuln.Severity ?: "Unknown"
                        // Normalize severity to match grype format (capitalize first letter, rest lowercase)
                        if (severity && severity.length() > 0) {
                            severity = severity.substring(0, 1).toUpperCase() + severity.substring(1).toLowerCase()
                        }
                        severityCounts[severity] = (severityCounts[severity] ?: 0) + 1
                        
                        if (vuln.FixedVersion && vuln.FixedVersion != "") {
                            fixableCount++
                            fixableVulnerabilities.add([
                                id: vuln.VulnerabilityID ?: "Unknown",
                                severity: severity,
                                package: vuln.PkgName ?: "Unknown",
                                version: vuln.InstalledVersion ?: "Unknown",
                                fixVersion: vuln.FixedVersion ?: "Unknown",
                                description: vuln.Description ?: ""
                            ])
                        }
                    }
                    
                    // Extract image name without tag for display
                    def imageDisplayName = imageName.split(':')[0]
                    def imageTag = imageName.contains(':') ? imageName.split(':')[1] : "latest"
                    
                    def result = [
                        projectName: imageDisplayName,
                        imageName: imageName,
                        totalVulnerabilities: vulnerabilities.size(),
                        severityCounts: severityCounts,
                        fixableCount: fixableCount,
                        fixableVulnerabilities: fixableVulnerabilities
                    ]
                    
                    allResults.add(result)
                    
                    // Save individual result file
                    def resultsFile = new File(resultsDir, "${imageDisplayName.replaceAll('/', '_')}-trivy-results.json")
                    resultsFile.text = new groovy.json.JsonBuilder(result).toPrettyString()
                    
                    // Display individual summary
                    def separator = "=================================================================================="
                    println "\n" + separator
                    println "TRIVY SCAN SUMMARY"
                    println separator
                    println "Image: ${imageName}"
                    println "Total vulnerabilities found: ${vulnerabilities.size()}"
                    
                    if (severityCounts.size() > 0) {
                        println "\nVulnerabilities by severity:"
                        def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                        severityOrder.each { severity ->
                            if (severityCounts.containsKey(severity)) {
                                println "  ${severity.padRight(12)}: ${severityCounts[severity]}"
                            }
                        }
                        severityCounts.each { severity, count ->
                            if (!severityOrder.contains(severity)) {
                                println "  ${severity.padRight(12)}: ${count}"
                            }
                        }
                    }
                    
                    if (fixableCount > 0) {
                        println "\nFixable vulnerabilities: ${fixableCount}"
                    }
                    
                    println separator + "\n"
                    
                } catch (Exception e) {
                    println "\nWarning: Could not parse trivy JSON output for ${imageName}: ${e.message}\n"
                }
            }
        }
        
        // Generate combined summary
        if (allResults.isEmpty()) {
            println "\nNo scan results to summarize."
            return
        }
        
        def totalVulnerabilities = 0
        def totalFixable = 0
        def combinedSeverityCounts = [:]
        
        allResults.each { result ->
            totalVulnerabilities += result.totalVulnerabilities ?: 0
            totalFixable += result.fixableCount ?: 0
            
            if (result.severityCounts) {
                result.severityCounts.each { severity, count ->
                    combinedSeverityCounts[severity] = (combinedSeverityCounts[severity] ?: 0) + count
                }
            }
        }
        
        // Build combined summary string
        def separator = "=================================================================================="
        def summary = new StringBuilder()
        summary.append("\n").append(separator).append("\n")
        summary.append("COMBINED TRIVY SCAN SUMMARY").append("\n")
        summary.append(separator).append("\n")
        summary.append("Scanned ${allResults.size()} image(s)").append("\n")
        summary.append("Total vulnerabilities found: ${totalVulnerabilities}").append("\n")
        
        if (combinedSeverityCounts.size() > 0) {
            summary.append("\nVulnerabilities by severity (combined):").append("\n")
            def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
            severityOrder.each { severity ->
                if (combinedSeverityCounts.containsKey(severity)) {
                    summary.append("  ${severity.padRight(12)}: ${combinedSeverityCounts[severity]}").append("\n")
                }
            }
            combinedSeverityCounts.each { severity, count ->
                if (!severityOrder.contains(severity)) {
                    summary.append("  ${severity.padRight(12)}: ${count}").append("\n")
                }
            }
        }
        
        if (totalFixable > 0) {
            summary.append("\nTotal fixable vulnerabilities: ${totalFixable}").append("\n")
        }
        
        summary.append("\nPer-image breakdown:").append("\n")
        allResults.sort { it.projectName }.each { result ->
            summary.append("\n  ${result.projectName}:").append("\n")
            summary.append("    Image: ${result.imageName}").append("\n")
            summary.append("    Total: ${result.totalVulnerabilities}").append("\n")
            if (result.severityCounts && result.severityCounts.size() > 0) {
                def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                def severityLine = severityOrder.findAll { result.severityCounts.containsKey(it) }
                    .collect { "${it}:${result.severityCounts[it]}" }
                    .join(", ")
                if (severityLine) {
                    summary.append("    Severities: ${severityLine}").append("\n")
                }
            }
            if (result.fixableCount > 0) {
                summary.append("    Fixable: ${result.fixableCount}").append("\n")
                
                // Display fixable vulnerabilities list
                if (result.fixableVulnerabilities && result.fixableVulnerabilities.size() > 0) {
                    summary.append("    Fixable vulnerabilities:").append("\n")
                    def severityOrder = ["Critical", "High", "Medium", "Low", "Negligible", "Unknown"]
                    def sortedFixable = result.fixableVulnerabilities.sort { vuln ->
                        def severityIndex = severityOrder.indexOf(vuln.severity ?: "Unknown")
                        if (severityIndex == -1) severityIndex = 999
                        [severityIndex, vuln.id ?: ""]
                    }
                    
                    sortedFixable.each { vuln ->
                        def pkgInfo = "${vuln.package}:${vuln.version}"
                        def fixInfo = vuln.fixVersion ? " -> ${vuln.fixVersion}" : ""
                        summary.append("      [${vuln.severity.padRight(9)}] ${vuln.id.padRight(20)} ${pkgInfo.padRight(40)}${fixInfo}").append("\n")
                    }
                }
            }
        }
        
        summary.append("\n").append(separator).append("\n")
        
        // Display summary to console
        println summary.toString()
        
        // Write summary to file
        def scanFile = layout.buildDirectory.file("trivy.scan.txt").get().asFile
        scanFile.text = summary.toString()
        println "Scan summary written to: ${scanFile.absolutePath}"
    }
}

task install {
    group = 'install'
    description = 'Install DeltaFi images built from this repo into the current development environment'
    dependsOn installPrerequisites
}

if (!deltafiConfig.isEmpty()) {
    var orchestrationMode = deltafiConfig['orchestrationMode'] ? deltafiConfig['orchestrationMode'].toLowerCase() : null
    if (orchestrationMode == 'kind') {
        task startKindCluster (type: Exec) {
            group = 'install'
            description = 'Configure KinD cluster to receive docker images'
            commandLine "deltafi", "kind", "up"
            dependsOn tui
        }
        installPrerequisites.dependsOn startKindCluster

        task syncKindPods (type: Exec) {
            group = 'install'
            description = 'Synchronize KinD orchestration so latest container images are running'
            commandLine "deltafi", "up", "--force"
            dependsOn tui
        }
    }
    if (orchestrationMode == 'compose') {
        task syncComposeServices (type: Exec) {
            group = 'install'
            description = 'Synchronize Compose orchestration so latest container images are running'
            commandLine "deltafi", "up", "--force"
            dependsOn tui
        }
    }
}

// Create tasks for each architecture
archDistroContents.each { arch, archFiles ->
    def archTask = tasks.create(name: "dist-${arch}", type: Tar) {
        dependsOn 'distBinaries'
        dependsOn 'decompressDistBinaries'
        group = 'distribution'
        description = "Creates distribution archive for ${arch}"

        // Configure archive properties
        archiveBaseName = "deltafi"
        archiveVersion = project.version
        archiveClassifier = arch
        compression = Compression.GZIP

        // Set output directory
        destinationDirectory = distroOutputDir

        // Include common files/directories
        commonDistroContents.each { item ->
            from(item.source) {
                into project.version + "/" + item.destination
                // Apply exclusions using Gradle's pattern syntax
                exclude excludePaths
                exclude {
                    details -> excludePaths.any { pattern ->
                        details.relativePath.pathString.startsWith(pattern.replace('**', ''))
                    }
                }
            }
        }

        // Include architecture-specific files/directories
        archFiles.each { item ->
            from(item.source) {
                into project.version + '/' + item.destination
                if (item.mode != null) {
                    fileMode = item.mode
                }
                if (item.rename != null) {
                    rename { _ -> item.rename }
                }
            }
            if (item.topLevel) {
                from(item.source) {
                    into '.'
                    if (item.mode != null) {
                        fileMode = item.mode
                    }
                    if (item.rename != null) {
                        rename { _ -> item.rename }
                    }
                }
            }
        }

        // Ensure reproducible builds
        preserveFileTimestamps = false
        reproducibleFileOrder = true

        // Ensure output directory exists
        doFirst {
            destinationDirectory.get().asFile.mkdirs()
        }
    }

    // Make the main distro task depend on this architecture-specific task
    dist.finalizedBy archTask
}

// Task to clean the distribution directory
task cleanDist(type: Delete) {
    group = 'distribution'
    description = 'Cleans the distribution directory'
    delete distroOutputDir
}

allprojects { project ->
    group 'org.deltafi'

    ext {
        isReleaseVersion = !version.endsWith("SNAPSHOT")
        isSignable = project.hasProperty("signing.keyId") && project.hasProperty("signing.password") && project.hasProperty("signing.secretKeyRingFile")
    }

    task resolveDeps {
        doLast {
            configurations.each { conf ->
                if (conf.isCanBeResolved()) {
                    conf.resolve()
                }
            }
        }
    }
}

subprojects {
    ext.deltafiConfig = rootProject.deltafiConfig
    task install {
        group = 'install'
        dependsOn rootProject.installPrerequisites
        dependsOn rootProject.tui
    }

    apply plugin: 'signing'

    afterEvaluate {
        // Configure grypeReport to depend on this project's grype task if it exists
        def grypeTask = tasks.findByName('grype')
        def grypeReportTask = rootProject.tasks.findByName('grypeReport')
        if (grypeTask != null && grypeReportTask != null && project.name in ['deltafi-core', 'deltafi-core-actions', 'deltafi-dirwatcher', 'deltafi-egress-sink', 'deltafi-nodemonitor']) {
            grypeReportTask.dependsOn grypeTask
        }
        // Configure trivyReport to depend on this project's trivy task if it exists
        def trivyTask = tasks.findByName('trivy')
        def trivyReportTask = rootProject.tasks.findByName('trivyReport')
        if (trivyTask != null && trivyReportTask != null && project.name in ['deltafi-core', 'deltafi-core-actions', 'deltafi-dirwatcher', 'deltafi-egress-sink', 'deltafi-nodemonitor']) {
            trivyReportTask.dependsOn trivyTask
        }
        var orchestrationMode = deltafiConfig['orchestrationMode'] ? deltafiConfig['orchestrationMode'].toLowerCase() : null
        if (orchestrationMode == 'kind') {
            tasks.matching { it.name == 'pushToKind' }.all {
                dependsOn rootProject.installPrerequisites
            }
        }

        // Only apply to subprojects with maven-publish applied
        pluginManager.withPlugin('maven-publish') {
            task javadocJar(type: Jar) {
                archiveClassifier = 'javadoc'
                dependsOn javadoc
                from javadoc
            }

            task sourcesJar(type: Jar) {
                archiveClassifier = 'sources'
                from sourceSets.main.allSource
            }

            artifacts {
                archives javadocJar, sourcesJar
            }

            publishing {
                repositories {
                    if (project.hasProperty('gitLabTokenType') && project.hasProperty('gitLabToken')) {
                        maven {
                            name "Gitlab"
                            url projectMavenRepo
                            credentials(HttpHeaderCredentials) {
                                // the following variables reside in ~/.gradle/gradle.properties
                                name = gitLabTokenType
                                value = gitLabToken
                            }
                            authentication {
                                header(HttpHeaderAuthentication)
                            }
                        }
                    }
                }

                if (project.name != 'gradle-plugin') {
                    publications {
                        Public(MavenPublication) {
                            from components.java
                            artifact sourcesJar
                            artifact javadocJar
                            pom {
                                name = project.name
                                description = project.description
                                url = 'https://www.deltafi.org'
                                inceptionYear = '2021'

                                licenses {
                                    license {
                                        name = 'The Apache Software License, Version 2.0'
                                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                                        distribution = 'repo'
                                    }
                                }
                                developers {
                                    developer {
                                         id = 'deltafi'
                                         name = 'DeltaFi Contributors'
                                         email = 'info@deltafi.org'
                                    }
                                }
                                scm {
                                    url = 'https://github.com/deltafi-org/deltafi'
                                    connection = 'scm:https://github.com/deltafi-org/deltafi.git'
                                    developerConnection = 'scm:git://github.com/deltafi-org/deltafi'
                                }
                            }
                        }
                    }
                }
            }

            install.dependsOn 'publishToMavenLocal'

            signing {
                required { isSignable }
            }

            if (project.name != 'gradle-plugin') {
                if (isSignable) {
                    signing {
                        sign publishing.publications
                    }
                }
            }
        }
    }
}

if (isReleaseVersion && project.hasProperty('sonatypeNexusUsername') && project.hasProperty('sonatypeNexusPassword')) {
    nexusPublishing {
        repositories {
            sonatype {  //only for users registered in Sonatype after 24 Feb 2021
                nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
                snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))
                password = sonatypeNexusPassword
                username = sonatypeNexusUsername
            }
        }
    }
}

// Log timings per task.
class TimingsListener implements TaskExecutionListener, BuildListener {
    private long startTime
    private timings = []

    @Override
    void beforeExecute(Task task) {
        startTime = System.nanoTime()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS)
        timings.add([ms, task.path])
        task.project.logger.warn "${task.path} took ${ms}ms"
    }

    @Override
    void buildFinished(BuildResult result) {
        println "Task timings:"
        for (timing in timings) {
            if (timing[0] >= 50) {
                printf "%7sms  %s\n", timing
            }
        }
    }

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}
}

// Cache all dependencies to maven local directory
task cacheToMavenLocal(type: Copy) {
    duplicatesStrategy DuplicatesStrategy.EXCLUDE
    from new File(gradle.gradleUserHomeDir, 'caches/modules-2/files-2.1')
        into repositories.mavenLocal().url
        eachFile {
            List<String> parts = it.path.split('/')
                it.path = parts[0].replace('.','/') + '/' + parts[1] + '/' + parts[2] + '/' + parts[4]
        }
    includeEmptyDirs false
    subprojects.each { dependsOn("${it.name}:resolveDeps") }
    dependsOn tasks.resolveDeps
}


gradle.addListener new TimingsListener()

