/**
 *    DeltaFi - Data transformation and enrichment platform
 *
 *    Copyright 2021-2025 DeltaFi Contributors <deltafi@deltafi.org>
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
plugins {
    id 'org.deltafi.git-version'
    id 'org.deltafi.plugin'
    id 'java'
    id 'jacoco'
    id 'org.springframework.boot'
    id 'com.palantir.docker'
}

dependencies {
    implementation "org.deltafi:deltafi-action-kit:${deltafiVersion}"

    compileOnly "org.projectlombok:lombok:1.18.30"
    annotationProcessor "org.projectlombok:lombok:1.18.30"
    testCompileOnly "org.projectlombok:lombok:1.18.30"
    testAnnotationProcessor "org.projectlombok:lombok:1.18.30"

    testImplementation "org.deltafi:deltafi-action-kit-test:${deltafiVersion}"
    testImplementation 'org.hamcrest:hamcrest:2.2'
    testImplementation "org.junit.jupiter:junit-jupiter-api:5.9.3"
    testImplementation "org.junit.jupiter:junit-jupiter-engine:5.9.3"
    testImplementation "org.mockito:mockito-junit-jupiter:5.3.1"
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

test {
    useJUnitPlatform()
}

jacocoTestReport {
    dependsOn test
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**/generated/**', '**/*Application.class'])
        }))
    }
}

jar {
    // do not create the -plain.jar
    enabled = false
}

springBoot {
    buildInfo {
        properties {
            additional = [
                    description: pluginDescription,
                    actionKitVersion: deltafiVersion
            ]
        }
    }
}

bootJar {
    dependsOn checkDeltafiPlugin
    setArchiveFileName "deltafi-plugin.jar"
}

// Copy the standard plugin Dockerfile from the gradle-plugin jar resources to the build directory after the bootJar is
// built. Here it will be available to both the gradle docker plugin and the CI docker job.
task copyPluginDockerfile(type: Copy) {
    def pluginDockerfile = resources.text.fromUri(
            Thread.currentThread().getContextClassLoader().getResource("PluginDockerfile").toURI()).asFile()
    from pluginDockerfile
    into buildDir
    rename { fileName -> fileName.replace(pluginDockerfile.getName(), "Dockerfile") }
}
bootJar.finalizedBy(copyPluginDockerfile)

dockerPrepare {
    dependsOn assemble
}

assemble {
    dependsOn copyPluginDockerfile
}

dockerfileZip {
    dependsOn copyPluginDockerfile
}

compileTestJava.dependsOn copyPluginDockerfile


// This prevents publishing tasks from failing due to 'task uses this output of task ':copyPluginDockerfile' without declaring an explicit or implicit dependency.
allprojects {
    plugins.withId('maven-publish') {
        tasks.withType(AbstractPublishToMaven).configureEach {
            dependsOn tasks.named('copyPluginDockerfile')
        }
    }
    task cacheToMavenLocal(type: Sync) {
        from new File(gradle.gradleUserHomeDir, 'caches/modules-2/files-2.1')
            into "${rootDir}/m2/repository"

            // Last copy target wins
            duplicatesStrategy = 'include'

            eachFile {
                List<String> parts = it.path.split('/')
                    // Construct a maven repo file tree from the path
                    it.path = parts[0].replace('.','/') +
                    '/' + parts[1] +
                    '/' + parts[2] +
                    '/' + parts[4]
            }

        includeEmptyDirs false
    }
}

docker {
    name "${project.name}:${project.version}"
    tag "local", "${localDockerRegistry}/${project.name}:latest"
    copySpec.from(bootJar.archiveFile).into("build/libs/")
    dockerfile file("${buildDir}/Dockerfile")
}

abstract class DocsExtension {
    abstract DirectoryProperty getDocsDirectory()
    abstract Property<String> getBasePackage()
}

def docsExtension = extensions.create('docsConfig', DocsExtension)
docsExtension.docsDirectory.convention(layout.buildDirectory.dir('docs'))
docsExtension.basePackage.convention(project.provider { project.group.toString() })

tasks.register('generateDocs', JavaExec) {
    dependsOn compileJava
    mustRunAfter copyPluginDockerfile
    classpath = sourceSets.main.compileClasspath + sourceSets.main.runtimeClasspath
    mainClass = 'org.deltafi.actionkit.documentation.ActionsDocumentationGenerator'

    doFirst {
        args = [docsExtension.docsDirectory.get().asFile, docsExtension.basePackage.get()]
    }

    group = 'deltafi'
    description = 'Generates action documentation for all actions within the group'
}
