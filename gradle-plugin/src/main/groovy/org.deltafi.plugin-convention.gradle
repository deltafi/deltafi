/**
 *    DeltaFi - Data transformation and enrichment platform
 *
 *    Copyright 2021-2025 DeltaFi Contributors <deltafi@deltafi.org>
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
plugins {
    id 'org.deltafi.git-version'
    id 'org.deltafi.plugin'
    id 'java'
    id 'jacoco'
    id 'org.springframework.boot'
    id 'com.palantir.docker'
}

dependencies {
    implementation "org.deltafi:deltafi-action-kit:${deltafiVersion}"

    compileOnly "org.projectlombok:lombok"
    annotationProcessor "org.projectlombok:lombok:1.18.42"
    testCompileOnly "org.projectlombok:lombok"
    testAnnotationProcessor "org.projectlombok:lombok:1.18.42"

    testImplementation "org.deltafi:deltafi-action-kit-test:${deltafiVersion}"
    testImplementation 'org.hamcrest:hamcrest:2.2'
    testImplementation "org.junit.jupiter:junit-jupiter-api"
    testImplementation "org.junit.jupiter:junit-jupiter-engine"
    testImplementation "org.mockito:mockito-junit-jupiter"
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

test {
    useJUnitPlatform()
}

jacocoTestReport {
    dependsOn test
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**/generated/**', '**/*Application.class'])
        }))
    }
}

jar {
    // do not create the -plain.jar
    enabled = false
}

springBoot {
    buildInfo {
        properties {
            additional = [
                    description: pluginDescription,
                    actionKitVersion: deltafiVersion
            ]
        }
        excludes = ['time']
    }
}

bootJar {
    dependsOn checkDeltafiPlugin
    setArchiveFileName "deltafi-plugin.jar"
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

// Copy the standard plugin Dockerfile from the gradle-plugin jar resources to the build directory after the bootJar is
// built. Here it will be available to both the gradle docker plugin and the CI docker job.
task copyPluginDockerfile(type: Copy) {
    def pluginDockerfile = resources.text.fromUri(
            Thread.currentThread().getContextClassLoader().getResource("PluginDockerfile").toURI()).asFile()
    from pluginDockerfile
    into buildDir
    rename { fileName -> fileName.replace(pluginDockerfile.getName(), "Dockerfile") }
}
bootJar.finalizedBy(copyPluginDockerfile)

dockerPrepare {
    dependsOn assemble
}

assemble {
    dependsOn copyPluginDockerfile
}

dockerfileZip {
    dependsOn copyPluginDockerfile
}

compileTestJava.dependsOn copyPluginDockerfile


// This prevents publishing tasks from failing due to 'task uses this output of task ':copyPluginDockerfile' without declaring an explicit or implicit dependency.
allprojects {
    plugins.withId('maven-publish') {
        tasks.withType(AbstractPublishToMaven).configureEach {
            dependsOn tasks.named('copyPluginDockerfile')
        }
    }
    task cacheToMavenLocal(type: Sync) {
        from new File(gradle.gradleUserHomeDir, 'caches/modules-2/files-2.1')
            into "${rootDir}/m2/repository"

            // Last copy target wins
            duplicatesStrategy = 'include'

            eachFile {
                List<String> parts = it.path.split('/')
                    // Construct a maven repo file tree from the path
                    it.path = parts[0].replace('.','/') +
                    '/' + parts[1] +
                    '/' + parts[2] +
                    '/' + parts[4]
            }

        includeEmptyDirs false
    }
}

// For SNAPSHOT versions, add timestamp to ensure unique tags for each build
ext.dockerTag = project.version.toString().contains('SNAPSHOT')
    ? "${project.version}-${new Date().format('yyyyMMdd-HHmmss')}"
    : project.version.toString()
ext.dockerImageName = "deltafi/${project.name}"

docker {
    name "${dockerImageName}:${dockerTag}"
    copySpec.from(bootJar.archiveFile).into("build/libs/")
    dockerfile file("${buildDir}/Dockerfile")
}

task install {
    group = 'install'
    description = 'Install plugin in local DeltaFi instance (plugin image will be built first)'
}

// Pretty print maps
import groovy.json.JsonBuilder
java.util.LinkedHashMap.metaClass.pprint = { -> new JsonBuilder(delegate).toPrettyString() }

import org.yaml.snakeyaml.Yaml
def loadDeltafiConfig() {
    def retval = [:];

    def homeDir = System.getenv('HOME');
    File testFile = new File(homeDir + '/.deltafi/config.yaml');

    if ( testFile.isFile() ) {
        retval = new Yaml().load(testFile.newInputStream());
        println ('Loaded configuration from ' + testFile.getPath());
    } else {
        println ('WARNING: ' + testFile.getPath() + ' not found');
    }
    retval = retval ?: [:]

    if (! retval.isEmpty()) println(retval.pprint());

    return retval;
}
ext.deltafiConfig = loadDeltafiConfig();

if (!deltafiConfig.isEmpty()) {
    var orchestrationMode = deltafiConfig['orchestrationMode'] ? deltafiConfig['orchestrationMode'].toLowerCase() : null

    // Task to clean up old SNAPSHOT images to prevent disk bloat
    task pruneOldSnapshots(type: Exec) {
        group = 'install'
        description = 'Remove old SNAPSHOT images for this plugin, keeping the 3 most recent'
        ignoreExitValue = true
        doFirst {
            def imageName = docker.name.toString().split(':')[0]
            commandLine 'sh', '-c', """
                docker images '${imageName}' --format '{{.CreatedAt}}\\t{{.Repository}}:{{.Tag}}' | \
                grep 'SNAPSHOT' | \
                sort -r | \
                tail -n +4 | \
                cut -f2 | \
                xargs -r docker rmi 2>/dev/null || true
            """
        }
    }

    if (orchestrationMode == 'kind') {
        task pushToKind(type: Exec) {
            group = 'install'
            description = 'Push docker image to KinD cluster'
            dependsOn "docker"
            doFirst {
                commandLine "deltafi", "kind", "load", docker.name.toString()
            }
        }
    }

    task deployPluginImage {
        if (orchestrationMode != null) {
            group = 'install'
            description = 'build and push docker images for ' + orchestrationMode + ' deployment'
        }
        if (orchestrationMode == 'compose') {
            dependsOn "pruneOldSnapshots", "docker"
        } else if (orchestrationMode == 'kind') {
            dependsOn "pruneOldSnapshots", "pushToKind"
        } else {
            println ('WARNING: Cannot install docker images for orchestration mode:' + deltafiConfig['orchestrationMode'])
        }
    }

    install.dependsOn 'deployPluginImage'

    if (orchestrationMode == 'compose' || orchestrationMode == 'kind') {
        task installPlugin(type: Exec) {
            workingDir deltafiConfig['installDirectory']
            doFirst {
                commandLine 'deltafi', 'plugin', 'install', docker.name.toString()
            }
        }
        installPlugin.dependsOn 'deployPluginImage'
        install.dependsOn 'installPlugin'

        task uninstall(type: Exec) {
            group = 'install'
            description = 'uninstall the plugin from local DeltaFi'
            workingDir deltafiConfig['installDirectory']
            commandLine 'deltafi', 'plugin', 'uninstall', "${project.name}"
        }
    }
}



abstract class DocsExtension {
    abstract DirectoryProperty getDocsDirectory()
    abstract Property<String> getBasePackage()
}

def docsExtension = extensions.create('docsConfig', DocsExtension)
docsExtension.docsDirectory.convention(layout.buildDirectory.dir('docs'))
docsExtension.basePackage.convention(project.provider { project.group.toString() })

tasks.register('generateDocs', JavaExec) {
    dependsOn compileJava
    mustRunAfter copyPluginDockerfile
    classpath = sourceSets.main.compileClasspath + sourceSets.main.runtimeClasspath
    mainClass = 'org.deltafi.actionkit.documentation.ActionsDocumentationGenerator'

    doFirst {
        args = [docsExtension.docsDirectory.get().asFile, docsExtension.basePackage.get()]
    }

    group = 'deltafi'
    description = 'Generates action documentation for all actions within the group'
}
